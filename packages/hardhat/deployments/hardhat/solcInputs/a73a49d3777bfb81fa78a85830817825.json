{
  "language": "Solidity",
  "sources": {
    "@onchain-id/solidity/contracts/ClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./interface/IClaimIssuer.sol\";\nimport \"./Identity.sol\";\n\ncontract ClaimIssuer is IClaimIssuer, Identity {\n    mapping (bytes => bool) public revokedClaims;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address initialManagementKey) Identity(initialManagementKey, false) {}\n\n    /**\n     *  @dev See {IClaimIssuer-revokeClaimBySignature}.\n     */\n    function revokeClaimBySignature(bytes calldata signature) external override delegatedOnly onlyManager {\n        require(!revokedClaims[signature], \"Conflict: Claim already revoked\");\n\n        revokedClaims[signature] = true;\n\n        emit ClaimRevoked(signature);\n    }\n\n    /**\n     *  @dev See {IClaimIssuer-revokeClaim}.\n     */\n    function revokeClaim(bytes32 _claimId, address _identity) external override delegatedOnly onlyManager returns(bool) {\n        uint256 foundClaimTopic;\n        uint256 scheme;\n        address issuer;\n        bytes memory sig;\n        bytes memory data;\n\n        ( foundClaimTopic, scheme, issuer, sig, data, ) = Identity(_identity).getClaim(_claimId);\n\n        require(!revokedClaims[sig], \"Conflict: Claim already revoked\");\n\n        revokedClaims[sig] = true;\n        emit ClaimRevoked(sig);\n        return true;\n    }\n\n    /**\n     *  @dev See {IClaimIssuer-isClaimValid}.\n     */\n    function isClaimValid(\n        IIdentity _identity,\n        uint256 claimTopic,\n        bytes memory sig,\n        bytes memory data)\n    public override(Identity, IClaimIssuer) view returns (bool claimValid)\n    {\n        bytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\n        // Use abi.encodePacked to concatenate the message prefix and the message to sign.\n        bytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash));\n\n        // Recover address of data signer\n        address recovered = getRecoveredAddress(sig, prefixedHash);\n\n        // Take hash of recovered address\n        bytes32 hashedAddr = keccak256(abi.encode(recovered));\n\n        // Does the trusted identifier have they key which signed the user's claim?\n        //  && (isClaimRevoked(_claimId) == false)\n        if (keyHasPurpose(hashedAddr, 3) && (isClaimRevoked(sig) == false)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     *  @dev See {IClaimIssuer-isClaimRevoked}.\n     */\n    function isClaimRevoked(bytes memory _sig) public override view returns (bool) {\n        if (revokedClaims[_sig]) {\n            return true;\n        }\n\n        return false;\n    }\n}\n"
    },
    "@onchain-id/solidity/contracts/Identity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./interface/IIdentity.sol\";\nimport \"./interface/IClaimIssuer.sol\";\nimport \"./version/Version.sol\";\nimport \"./storage/Storage.sol\";\n\n/**\n * @dev Implementation of the `IERC734` \"KeyHolder\" and the `IERC735` \"ClaimHolder\" interfaces\n * into a common Identity Contract.\n * This implementation has a separate contract were it declares all storage,\n * allowing for it to be used as an upgradable logic contract.\n */\ncontract Identity is Storage, IIdentity, Version {\n\n    /**\n     * @notice Prevent any direct calls to the implementation contract (marked by _canInteract = false).\n     */\n    modifier delegatedOnly() {\n        require(_canInteract == true, \"Interacting with the library contract is forbidden.\");\n        _;\n    }\n\n    /**\n     * @notice requires management key to call this function, or internal call\n     */\n    modifier onlyManager() {\n        require(msg.sender == address(this) || keyHasPurpose(keccak256(abi.encode(msg.sender)), 1)\n        , \"Permissions: Sender does not have management key\");\n        _;\n    }\n\n    /**\n     * @notice requires claim key to call this function, or internal call\n     */\n    modifier onlyClaimKey() {\n        require(msg.sender == address(this) || keyHasPurpose(keccak256(abi.encode(msg.sender)), 3)\n        , \"Permissions: Sender does not have claim signer key\");\n        _;\n    }\n\n    /**\n     * @notice constructor of the Identity contract\n     * @param initialManagementKey the address of the management key at deployment\n     * @param _isLibrary boolean value stating if the contract is library or not\n     * calls __Identity_init if contract is not library\n     */\n    constructor(address initialManagementKey, bool _isLibrary) {\n        require(initialManagementKey != address(0), \"invalid argument - zero address\");\n\n        if (!_isLibrary) {\n            __Identity_init(initialManagementKey);\n        } else {\n            _initialized = true;\n        }\n    }\n\n    /**\n     * @notice When using this contract as an implementation for a proxy, call this initializer with a delegatecall.\n     *\n     * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\n     */\n    function initialize(address initialManagementKey) external {\n        require(initialManagementKey != address(0), \"invalid argument - zero address\");\n        __Identity_init(initialManagementKey);\n    }\n\n    /**\n     * @dev See {IERC734-execute}.\n     * @notice Passes an execution instruction to the keymanager.\n     * If the sender is an ACTION key and the destination address is not the identity contract itself, then the\n     * execution is immediately approved and performed.\n     * If the destination address is the identity itself, then the execution would be performed immediately only if\n     * the sender is a MANAGEMENT key.\n     * Otherwise the execution request must be approved via the `approve` method.\n     * @return executionId to use in the approve function, to approve or reject this execution.\n     */\n    function execute(address _to, uint256 _value, bytes memory _data)\n    external\n    delegatedOnly\n    override\n    payable\n    returns (uint256 executionId)\n    {\n        uint256 _executionId = _executionNonce;\n        _executions[_executionId].to = _to;\n        _executions[_executionId].value = _value;\n        _executions[_executionId].data = _data;\n        _executionNonce++;\n\n        emit ExecutionRequested(_executionId, _to, _value, _data);\n\n        if (keyHasPurpose(keccak256(abi.encode(msg.sender)), 1)) {\n            approve(_executionId, true);\n        }\n        else if (_to != address(this) && keyHasPurpose(keccak256(abi.encode(msg.sender)), 2)){\n            approve(_executionId, true);\n        }\n\n        return _executionId;\n    }\n\n    /**\n     * @dev See {IERC734-getKey}.\n     * @notice Implementation of the getKey function from the ERC-734 standard\n     * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\n     * @return purposes Returns the full key data, if present in the identity.\n     * @return keyType Returns the full key data, if present in the identity.\n     * @return key Returns the full key data, if present in the identity.\n     */\n    function getKey(bytes32 _key)\n    external\n    override\n    view\n    returns(uint256[] memory purposes, uint256 keyType, bytes32 key)\n    {\n        return (_keys[_key].purposes, _keys[_key].keyType, _keys[_key].key);\n    }\n\n    /**\n    * @dev See {IERC734-getKeyPurposes}.\n    * @notice gets the purposes of a key\n    * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\n    * @return _purposes Returns the purposes of the specified key\n    */\n    function getKeyPurposes(bytes32 _key)\n    external\n    override\n    view\n    returns(uint256[] memory _purposes)\n    {\n        return (_keys[_key].purposes);\n    }\n\n    /**\n    * @dev See {IERC734-getKeysByPurpose}.\n    * @notice gets all the keys with a specific purpose from an identity\n    * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\n    * @return keys Returns an array of public key bytes32 hold by this identity and having the specified purpose\n    */\n    function getKeysByPurpose(uint256 _purpose)\n    external\n    override\n    view\n    returns(bytes32[] memory keys)\n    {\n        return _keysByPurpose[_purpose];\n    }\n\n    /**\n    * @dev See {IERC735-getClaimIdsByTopic}.\n    * @notice Implementation of the getClaimIdsByTopic function from the ERC-735 standard.\n    * used to get all the claims from the specified topic\n    * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n    * @return claimIds Returns an array of claim IDs by topic.\n    */\n    function getClaimIdsByTopic(uint256 _topic)\n    external\n    override\n    view\n    returns(bytes32[] memory claimIds)\n    {\n        return _claimsByTopic[_topic];\n    }\n\n    /**\n    * @notice implementation of the addKey function of the ERC-734 standard\n    * Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes:\n    * 1: MANAGEMENT keys, which can manage the identity\n    * 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.)\n    * 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable.\n    * 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims.\n    * MUST only be done by keys of purpose 1, or the identity itself.\n    * If its the identity itself, the approval process will determine its approval.\n    * @param _key keccak256 representation of an ethereum address\n    * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\n    * @param _purpose a uint256 specifying the key type, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\n    * @return success Returns TRUE if the addition was successful and FALSE if not\n    */\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _type)\n    public\n    delegatedOnly\n    onlyManager\n    override\n    returns (bool success)\n    {\n        if (_keys[_key].key == _key) {\n            uint256[] memory _purposes = _keys[_key].purposes;\n            for (uint keyPurposeIndex = 0; keyPurposeIndex < _purposes.length; keyPurposeIndex++) {\n                uint256 purpose = _purposes[keyPurposeIndex];\n\n                if (purpose == _purpose) {\n                    revert(\"Conflict: Key already has purpose\");\n                }\n            }\n\n            _keys[_key].purposes.push(_purpose);\n        } else {\n            _keys[_key].key = _key;\n            _keys[_key].purposes = [_purpose];\n            _keys[_key].keyType = _type;\n        }\n\n        _keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    /**\n     *  @dev See {IERC734-approve}.\n     *  @notice Approves an execution.\n     *  If the sender is an ACTION key and the destination address is not the identity contract itself, then the\n     *  approval is authorized and the operation would be performed.\n     *  If the destination address is the identity itself, then the execution would be authorized and performed only\n     *  if the sender is a MANAGEMENT key.\n     */\n    function approve(uint256 _id, bool _approve)\n    public\n    delegatedOnly\n    override\n    returns (bool success)\n    {\n        require(_id < _executionNonce, \"Cannot approve a non-existing execution\");\n        require(!_executions[_id].executed, \"Request already executed\");\n\n        if(_executions[_id].to == address(this)) {\n            require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 1), \"Sender does not have management key\");\n        }\n        else {\n            require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), \"Sender does not have action key\");\n        }\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _executions[_id].approved = true;\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (success,) = _executions[_id].to.call{value:(_executions[_id].value)}(_executions[_id].data);\n\n            if (success) {\n                _executions[_id].executed = true;\n\n                emit Executed(\n                    _id,\n                    _executions[_id].to,\n                    _executions[_id].value,\n                    _executions[_id].data\n                );\n\n                return true;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _executions[_id].to,\n                    _executions[_id].value,\n                    _executions[_id].data\n                );\n\n                return false;\n            }\n        } else {\n            _executions[_id].approved = false;\n        }\n        return false;\n    }\n\n    /**\n    * @dev See {IERC734-removeKey}.\n    * @notice Remove the purpose from a key.\n    */\n    function removeKey(bytes32 _key, uint256 _purpose)\n    public\n    delegatedOnly\n    onlyManager\n    override\n    returns (bool success)\n    {\n        require(_keys[_key].key == _key, \"NonExisting: Key isn't registered\");\n        uint256[] memory _purposes = _keys[_key].purposes;\n\n        uint purposeIndex = 0;\n        while (_purposes[purposeIndex] != _purpose) {\n            purposeIndex++;\n\n            if (purposeIndex == _purposes.length) {\n                revert(\"NonExisting: Key doesn't have such purpose\");\n            }\n        }\n\n        _purposes[purposeIndex] = _purposes[_purposes.length - 1];\n        _keys[_key].purposes = _purposes;\n        _keys[_key].purposes.pop();\n\n        uint keyIndex = 0;\n        uint arrayLength = _keysByPurpose[_purpose].length;\n\n        while (_keysByPurpose[_purpose][keyIndex] != _key) {\n            keyIndex++;\n\n            if (keyIndex >= arrayLength) {\n                break;\n            }\n        }\n\n        _keysByPurpose[_purpose][keyIndex] = _keysByPurpose[_purpose][arrayLength - 1];\n        _keysByPurpose[_purpose].pop();\n\n        uint keyType = _keys[_key].keyType;\n\n        if (_purposes.length - 1 == 0) {\n            delete _keys[_key];\n        }\n\n        emit KeyRemoved(_key, _purpose, keyType);\n\n        return true;\n    }\n\n    /**\n    * @dev See {IERC735-addClaim}.\n    * @notice Implementation of the addClaim function from the ERC-735 standard\n    *  Require that the msg.sender has claim signer key.\n    *\n    * @param _topic The type of claim\n    * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.\n    * @param _issuer The issuers identity contract address, or the address used to sign the above signature.\n    * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity.\n    * it MUST be a signed message of the following structure:\n    * keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))\n    * @param _data The hash of the claim data, sitting in another\n    * location, a bit-mask, call data, or actual data based on the claim scheme.\n    * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\n    *\n    * @return claimRequestId Returns claimRequestId: COULD be\n    * send to the approve function, to approve or reject this claim.\n    * triggers ClaimAdded event.\n    */\n    function addClaim(\n        uint256 _topic,\n        uint256 _scheme,\n        address _issuer,\n        bytes memory _signature,\n        bytes memory _data,\n        string memory _uri\n    )\n    public\n    delegatedOnly\n    onlyClaimKey\n    override\n    returns (bytes32 claimRequestId)\n    {\n        if (_issuer != address(this)) {\n            require(IClaimIssuer(_issuer).isClaimValid(IIdentity(address(this)), _topic, _signature, _data), \"invalid claim\");\n        }\n\n        bytes32 claimId = keccak256(abi.encode(_issuer, _topic));\n        _claims[claimId].topic = _topic;\n        _claims[claimId].scheme = _scheme;\n        _claims[claimId].signature = _signature;\n        _claims[claimId].data = _data;\n        _claims[claimId].uri = _uri;\n\n        if (_claims[claimId].issuer != _issuer) {\n            _claimsByTopic[_topic].push(claimId);\n            _claims[claimId].issuer = _issuer;\n\n            emit ClaimAdded(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n        }\n        else {\n            emit ClaimChanged(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n        }\n        return claimId;\n    }\n\n    /**\n    * @dev See {IERC735-removeClaim}.\n    * @notice Implementation of the removeClaim function from the ERC-735 standard\n    * Require that the msg.sender has management key.\n    * Can only be removed by the claim issuer, or the claim holder itself.\n    *\n    * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n    *\n    * @return success Returns TRUE when the claim was removed.\n    * triggers ClaimRemoved event\n    */\n    function removeClaim(bytes32 _claimId)\n    public\n    delegatedOnly\n    onlyClaimKey\n    override\n    returns\n    (bool success) {\n        uint256 _topic = _claims[_claimId].topic;\n        if (_topic == 0) {\n            revert(\"NonExisting: There is no claim with this ID\");\n        }\n\n        uint claimIndex = 0;\n        uint arrayLength = _claimsByTopic[_topic].length;\n        while (_claimsByTopic[_topic][claimIndex] != _claimId) {\n            claimIndex++;\n\n            if (claimIndex >= arrayLength) {\n                break;\n            }\n        }\n\n        _claimsByTopic[_topic][claimIndex] =\n        _claimsByTopic[_topic][arrayLength - 1];\n        _claimsByTopic[_topic].pop();\n\n        emit ClaimRemoved(\n            _claimId,\n            _topic,\n            _claims[_claimId].scheme,\n            _claims[_claimId].issuer,\n            _claims[_claimId].signature,\n            _claims[_claimId].data,\n            _claims[_claimId].uri\n        );\n\n        delete _claims[_claimId];\n\n        return true;\n    }\n\n    /**\n    * @dev See {IERC735-getClaim}.\n    * @notice Implementation of the getClaim function from the ERC-735 standard.\n    *\n    * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n    *\n    * @return topic Returns all the parameters of the claim for the\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n    * @return scheme Returns all the parameters of the claim for the\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n    * @return issuer Returns all the parameters of the claim for the\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n    * @return signature Returns all the parameters of the claim for the\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n    * @return data Returns all the parameters of the claim for the\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n    * @return uri Returns all the parameters of the claim for the\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n    */\n    function getClaim(bytes32 _claimId)\n    public\n    override\n    view\n    returns(\n        uint256 topic,\n        uint256 scheme,\n        address issuer,\n        bytes memory signature,\n        bytes memory data,\n        string memory uri\n    )\n    {\n        return (\n        _claims[_claimId].topic,\n        _claims[_claimId].scheme,\n        _claims[_claimId].issuer,\n        _claims[_claimId].signature,\n        _claims[_claimId].data,\n        _claims[_claimId].uri\n        );\n    }\n\n    /**\n    * @dev See {IERC734-keyHasPurpose}.\n    * @notice Returns true if the key has MANAGEMENT purpose or the specified purpose.\n    */\n    function keyHasPurpose(bytes32 _key, uint256 _purpose)\n    public\n    override\n    view\n    returns(bool result)\n    {\n        Key memory key = _keys[_key];\n        if (key.key == 0) return false;\n\n        for (uint keyPurposeIndex = 0; keyPurposeIndex < key.purposes.length; keyPurposeIndex++) {\n            uint256 purpose = key.purposes[keyPurposeIndex];\n\n            if (purpose == 1 || purpose == _purpose) return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Checks if a claim is valid. Claims issued by the identity are self-attested claims. They do not have a\n     * built-in revocation mechanism and are considered valid as long as their signature is valid and they are still\n     * stored by the identity contract.\n     * @param _identity the identity contract related to the claim\n     * @param claimTopic the claim topic of the claim\n     * @param sig the signature of the claim\n     * @param data the data field of the claim\n     * @return claimValid true if the claim is valid, false otherwise\n     */\n    function isClaimValid(\n        IIdentity _identity,\n        uint256 claimTopic,\n        bytes memory sig,\n        bytes memory data)\n    public override virtual view returns (bool claimValid)\n    {\n        bytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\n        // Use abi.encodePacked to concatenate the message prefix and the message to sign.\n        bytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash));\n\n        // Recover address of data signer\n        address recovered = getRecoveredAddress(sig, prefixedHash);\n\n        // Take hash of recovered address\n        bytes32 hashedAddr = keccak256(abi.encode(recovered));\n\n        // Does the trusted identifier have they key which signed the user's claim?\n        //  && (isClaimRevoked(_claimId) == false)\n        if (keyHasPurpose(hashedAddr, 3)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev returns the address that signed the given data\n     * @param sig the signature of the data\n     * @param dataHash the data that was signed\n     * returns the address that signed dataHash and created the signature sig\n     */\n    function getRecoveredAddress(bytes memory sig, bytes32 dataHash)\n    public\n    pure\n    returns (address addr)\n    {\n        bytes32 ra;\n        bytes32 sa;\n        uint8 va;\n\n        // Check the signature length\n        if (sig.length != 65) {\n            return address(0);\n        }\n\n        // Divide the signature in r, s and v variables\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ra := mload(add(sig, 32))\n            sa := mload(add(sig, 64))\n            va := byte(0, mload(add(sig, 96)))\n        }\n\n        if (va < 27) {\n            va += 27;\n        }\n\n        address recoveredAddress = ecrecover(dataHash, va, ra, sa);\n\n        return (recoveredAddress);\n    }\n\n    /**\n     * @notice Initializer internal function for the Identity contract.\n     *\n     * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __Identity_init(address initialManagementKey) internal {\n        require(!_initialized || _isConstructor(), \"Initial key was already setup.\");\n        _initialized = true;\n        _canInteract = true;\n\n        bytes32 _key = keccak256(abi.encode(initialManagementKey));\n        _keys[_key].key = _key;\n        _keys[_key].purposes = [1];\n        _keys[_key].keyType = 1;\n        _keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    /**\n     * @notice Computes if the context in which the function is called is a constructor or not.\n     *\n     * @return true if the context is a constructor.\n     */\n    function _isConstructor() private view returns (bool) {\n        address self = address(this);\n        uint256 cs;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { cs := extcodesize(self) }\n        return cs == 0;\n    }\n}\n"
    },
    "@onchain-id/solidity/contracts/interface/IClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IIdentity.sol\";\n\ninterface IClaimIssuer is IIdentity {\n\n    /**\n     * @dev Emitted when a claim is revoked.\n     *\n     * Specification: MUST be triggered when revoking a claim.\n     */\n    event ClaimRevoked(bytes indexed signature);\n\n    /**\n     * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n     * @notice will fetch the claim from the identity contract (unsafe).\n     * @param _claimId the id of the claim\n     * @param _identity the address of the identity contract\n     * @return isRevoked true when the claim is revoked\n     */\n    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);\n\n    /**\n     * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n     * @param signature the signature of the claim\n     */\n    function revokeClaimBySignature(bytes calldata signature) external;\n\n    /**\n     * @dev Returns revocation status of a claim.\n     * @param _sig the signature of the claim\n     * @return isRevoked true if the claim is revoked and false otherwise\n     */\n    function isClaimRevoked(bytes calldata _sig) external view returns (bool);\n\n    /**\n     * @dev Checks if a claim is valid.\n     * @param _identity the identity contract related to the claim\n     * @param claimTopic the claim topic of the claim\n     * @param sig the signature of the claim\n     * @param data the data field of the claim\n     * @return claimValid true if the claim is valid, false otherwise\n     */\n    function isClaimValid(\n        IIdentity _identity,\n        uint256 claimTopic,\n        bytes calldata sig,\n        bytes calldata data)\n    external view returns (bool);\n}\n"
    },
    "@onchain-id/solidity/contracts/interface/IERC734.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\n */\ninterface IERC734 {\n\n    /**\n     * @dev Emitted when an execution request was approved.\n     *\n     * Specification: MUST be triggered when approve was successfully called.\n     */\n    event Approved(uint256 indexed executionId, bool approved);\n\n    /**\n     * @dev Emitted when an execute operation was approved and successfully performed.\n     *\n     * Specification: MUST be triggered when approve was called and the execution was successfully approved.\n     */\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n    /**\n     * @dev Emitted when an execution request was performed via `execute`.\n     *\n     * Specification: MUST be triggered when execute was successfully called.\n     */\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n    /**\n     * @dev Emitted when an execute operation was called and failed\n     *\n     * Specification: MUST be triggered when execute call failed\n     */\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n    /**\n     * @dev Emitted when a key was added to the Identity.\n     *\n     * Specification: MUST be triggered when addKey was successfully called.\n     */\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n    /**\n     * @dev Emitted when a key was removed from the Identity.\n     *\n     * Specification: MUST be triggered when removeKey was successfully called.\n     */\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n    /**\n     * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\n     *\n     * Triggers Event: `KeyAdded`\n     *\n     * Specification: MUST only be done by keys of purpose 1, or the identity\n     * itself. If it's the identity itself, the approval process will determine its approval.\n     */\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\n\n    /**\n    * @dev Approves an execution.\n    *\n    * Triggers Event: `Approved`\n    * Triggers on execution successful Event: `Executed`\n    * Triggers on execution failure Event: `ExecutionFailed`\n    */\n    function approve(uint256 _id, bool _approve) external returns (bool success);\n\n    /**\n     * @dev Removes _purpose for _key from the identity.\n     *\n     * Triggers Event: `KeyRemoved`\n     *\n     * Specification: MUST only be done by keys of purpose 1, or the identity itself.\n     * If it's the identity itself, the approval process will determine its approval.\n     */\n    function removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\n\n    /**\n     * @dev Passes an execution instruction to an ERC734 identity.\n     * How the execution is handled is up to the identity implementation:\n     * An execution COULD be requested and require `approve` to be called with one or more keys of purpose 1 or 2 to\n     * approve this execution.\n     * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\n     *\n     * Triggers Event: ExecutionRequested\n     * Triggers on direct execution Event: Executed\n     */\n    function execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\n\n    /**\n     * @dev Returns the full key data, if present in the identity.\n     */\n    function getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\n\n    /**\n     * @dev Returns the list of purposes associated with a key.\n     */\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory _purposes);\n\n    /**\n     * @dev Returns an array of public key bytes32 held by this identity.\n     */\n    function getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\n\n    /**\n     * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\n     */\n    function keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\n}\n"
    },
    "@onchain-id/solidity/contracts/interface/IERC735.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.\n */\ninterface IERC735 {\n\n    /**\n     * @dev Emitted when a claim was added.\n     *\n     * Specification: MUST be triggered when a claim was successfully added.\n     */\n    event ClaimAdded(\n        bytes32 indexed claimId,\n        uint256 indexed topic,\n        uint256 scheme,\n        address indexed issuer,\n        bytes signature,\n        bytes data,\n        string uri);\n\n    /**\n     * @dev Emitted when a claim was removed.\n     *\n     * Specification: MUST be triggered when removeClaim was successfully called.\n     */\n    event ClaimRemoved(\n        bytes32 indexed claimId,\n        uint256 indexed topic,\n        uint256 scheme,\n        address indexed issuer,\n        bytes signature,\n        bytes data,\n        string uri);\n\n    /**\n     * @dev Emitted when a claim was changed.\n     *\n     * Specification: MUST be triggered when addClaim was successfully called on an existing claimId.\n     */\n    event ClaimChanged(\n        bytes32 indexed claimId,\n        uint256 indexed topic,\n        uint256 scheme,\n        address indexed issuer,\n        bytes signature,\n        bytes data,\n        string uri);\n\n    /**\n     * @dev Add or update a claim.\n     *\n     * Triggers Event: `ClaimAdded`, `ClaimChanged`\n     *\n     * Specification: Add or update a claim from an issuer.\n     *\n     * _signature is a signed message of the following structure:\n     * `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.\n     */\n    function addClaim(\n        uint256 _topic,\n        uint256 _scheme,\n        address issuer,\n        bytes calldata _signature,\n        bytes calldata _data,\n        string calldata _uri)\n    external returns (bytes32 claimRequestId);\n\n    /**\n     * @dev Removes a claim.\n     *\n     * Triggers Event: `ClaimRemoved`\n     *\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n     */\n    function removeClaim(bytes32 _claimId) external returns (bool success);\n\n    /**\n     * @dev Get a claim by its ID.\n     *\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n     */\n    function getClaim(bytes32 _claimId)\n    external view returns(\n        uint256 topic,\n        uint256 scheme,\n        address issuer,\n        bytes memory signature,\n        bytes memory data,\n        string memory uri);\n\n    /**\n     * @dev Returns an array of claim IDs by topic.\n     */\n    function getClaimIdsByTopic(uint256 _topic) external view returns(bytes32[] memory claimIds);\n}\n"
    },
    "@onchain-id/solidity/contracts/interface/IIdentity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IERC734.sol\";\nimport \"./IERC735.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface IIdentity is IERC734, IERC735 {\n    /**\n     * @dev Checks if a claim is valid.\n     * @param _identity the identity contract related to the claim\n     * @param claimTopic the claim topic of the claim\n     * @param sig the signature of the claim\n     * @param data the data field of the claim\n     * @return claimValid true if the claim is valid, false otherwise\n     */\n    function isClaimValid(\n        IIdentity _identity,\n        uint256 claimTopic,\n        bytes calldata sig,\n        bytes calldata data)\n    external view returns (bool);\n}\n"
    },
    "@onchain-id/solidity/contracts/storage/Storage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\nimport \"./Structs.sol\";\n\ncontract Storage is Structs {\n    // nonce used by the execute/approve function\n    uint256 internal _executionNonce;\n\n    // keys as defined by IERC734\n    mapping(bytes32 => Key) internal _keys;\n\n    // keys for a given purpose\n    // purpose 1 = MANAGEMENT\n    // purpose 2 = ACTION\n    // purpose 3 = CLAIM\n    mapping(uint256 => bytes32[]) internal _keysByPurpose;\n\n    // execution data\n    mapping(uint256 => Execution) internal _executions;\n\n    // claims held by the ONCHAINID\n    mapping(bytes32 => Claim) internal _claims;\n\n    // array of claims for a given topic\n    mapping(uint256 => bytes32[]) internal _claimsByTopic;\n\n    // status on initialization\n    bool internal _initialized = false;\n\n    // status on potential interactions with the contract\n    bool internal _canInteract = false;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@onchain-id/solidity/contracts/storage/Structs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ncontract Structs {\n\n   /**\n    *  @dev Definition of the structure of a Key.\n    *\n    *  Specification: Keys are cryptographic public keys, or contract addresses associated with this identity.\n    *  The structure should be as follows:\n    *  key: A public key owned by this identity\n    *  purposes: uint256[] Array of the key purposes, like 1 = MANAGEMENT, 2 = EXECUTION\n    *  keyType: The type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\n    *  key: bytes32 The public key. // Its the Keccak256 hash of the key\n    */\n    struct Key {\n        uint256[] purposes;\n        uint256 keyType;\n        bytes32 key;\n    }\n\n    /**\n    *  @dev Definition of the structure of an Execution\n    *\n    *  Specification: Executions are requests for transactions to be issued by the ONCHAINID\n    *  to: address of contract to interact with, can be address(this)\n    *  value: ETH to transfer with the transaction\n    *  data: payload of the transaction to execute\n    *  approved: approval status of the Execution\n    *  executed: execution status of the Execution (set as false when the Execution is created\n    *  and updated to true when the Execution is processed)\n    */\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n   /**\n    *  @dev Definition of the structure of a Claim.\n    *\n    *  Specification: Claims are information an issuer has about the identity holder.\n    *  The structure should be as follows:\n    *  claim: A claim published for the Identity.\n    *  topic: A uint256 number which represents the topic of the claim. (e.g. 1 biometric, 2 residence (ToBeDefined:\n    *  number schemes, sub topics based on number ranges??))\n    *  scheme : The scheme with which this claim SHOULD be verified or how it should be processed. Its a uint256 for\n    *  different schemes. E.g. could 3 mean contract verification, where the data will be call data, and the issuer a\n    *  contract address to call (ToBeDefined). Those can also mean different key types e.g. 1 = ECDSA, 2 = RSA, etc.\n    *  (ToBeDefined)\n    *  issuer: The issuers identity contract address, or the address used to sign the above signature. If an\n    *  identity contract, it should hold the key with which the above message was signed, if the key is not present\n    *  anymore, the claim SHOULD be treated as invalid. The issuer can also be a contract address itself, at which the\n    *  claim can be verified using the call data.\n    *  signature: Signature which is the proof that the claim issuer issued a claim of topic for this identity. it\n    *  MUST be a signed message of the following structure: `keccak256(abi.encode(identityHolder_address, topic, data))`\n    *  data: The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on\n    *  the claim scheme.\n    *  uri: The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\n    */\n    struct Claim {\n        uint256 topic;\n        uint256 scheme;\n        address issuer;\n        bytes signature;\n        bytes data;\n        string uri;\n    }\n}\n"
    },
    "@onchain-id/solidity/contracts/version/Version.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\n/**\n * @dev Version contract gives the versioning information of the implementation contract\n */\ncontract Version {\n    /**\n     * @dev Returns the string of the current version.\n     */\n    function version() external pure returns (string memory) {\n        // version 2.2.0\n        return \"2.2.1\";\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/_testContracts/ClaimIssuerTrick.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\ncontract ClaimIssuerTrick {\r\n    function isClaimValid(\r\n        address _identity,\r\n        uint256,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) public view returns (bool) {\r\n        if (msg.sender == _identity) {\r\n            return true;\r\n        }\r\n\r\n        revert(\"ERROR\");\r\n    }\r\n}\r\n"
    },
    "contracts/_testContracts/FalseCompliance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"../compliance/interface/ICompliance.sol\";\r\nimport \"../token/IToken.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\n\r\ncontract FalseCompliance is ICompliance, AccessControl {\r\n    /// Mapping between agents and their statuses\r\n    mapping(address => bool) private _tokenAgentsList;\r\n    /// Mapping of tokens linked to the compliance contract\r\n    IToken public tokenBound;\r\n\r\n    // keccak256(ADMIN_ROLE)\r\n    bytes32 public constant ADMIN_ROLE =\r\n        0xa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775;\r\n\r\n    // keccak256(TOKEN_ROLE)\r\n    bytes32 public constant TOKEN_ROLE =\r\n        0xa7197c38d9c4c7450c7f2cd20d0a17cbe7c344190d6c82a6b49a146e62439ae4;\r\n\r\n    constructor() {\r\n        _grantRole(0x00, _msgSender());\r\n        _grantRole(ADMIN_ROLE, _msgSender());\r\n    }\r\n\r\n    /**\r\n     *  @dev See {ICompliance-bindToken}.\r\n     */\r\n    function bindToken(address _token) external {\r\n        require(\r\n            hasRole(ADMIN_ROLE, _msgSender()) ||\r\n                hasRole(ADMIN_ROLE, _msgSender()) ||\r\n                address(tokenBound) == address(0),\r\n            \"ERC-3643: Caller not authorized\"\r\n        );\r\n        tokenBound = IToken(_token);\r\n        emit TokenBound(_token);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {ICompliance-unbindToken}.\r\n     */\r\n    function unbindToken(address _token) external {\r\n        require(\r\n            hasRole(ADMIN_ROLE, _msgSender()) ||\r\n                hasRole(TOKEN_ROLE, _msgSender()),\r\n            \"ERC-3643: Caller not authorized\"\r\n        );\r\n        require(_token == address(tokenBound), \"ERC-3643: Token not bound\");\r\n        delete tokenBound;\r\n        emit TokenUnbound(_token);\r\n    }\r\n\r\n    /*\r\n     *  @dev See {ICompliance-transferred}.\r\n     */\r\n    function transferred(address _from, address _to, uint256 _value) external {}\r\n\r\n    /**\r\n     *  @dev See {ICompliance-created}.\r\n     */\r\n\r\n    function created(address _to, uint256 _value) external {}\r\n\r\n    /**\r\n     *  @dev See {ICompliance-destroyed}.\r\n     */\r\n    function destroyed(address _from, uint256 _value) external {}\r\n\r\n    /**\r\n     *  @dev See {ICompliance-canTransfer}.\r\n     */\r\n    function canTransfer(\r\n        address /*_from*/,\r\n        address /*_to*/,\r\n        uint256 /*_value*/\r\n    ) external view returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *  @dev See {ICompliance-isTokenBound}.\r\n     */\r\n    function isTokenBound(address _token) external view returns (bool) {\r\n        return (_token == address(tokenBound));\r\n    }\r\n\r\n    /**\r\n     *  @dev Returns the ONCHAINID (Identity) of the _userAddress\r\n     *  @param _userAddress Address of the wallet\r\n     *  internal function, can be called only from the functions of the Compliance smart contract\r\n     */\r\n    function _getIdentity(\r\n        address _userAddress\r\n    ) internal view returns (address) {\r\n        return address(tokenBound.identityRegistry().identity(_userAddress));\r\n    }\r\n\r\n    /**\r\n     *  @dev Returns the country of residence of the _userAddress\r\n     *  @param _userAddress Address of the wallet\r\n     *  internal function, can be called only from the functions of the Compliance smart contract\r\n     */\r\n    function _getCountry(address _userAddress) internal view returns (uint16) {\r\n        return tokenBound.identityRegistry().investorCountry(_userAddress);\r\n    }\r\n}\r\n"
    },
    "contracts/_testContracts/IdentityTrick.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"@onchain-id/solidity/contracts/Identity.sol\";\r\n\r\nabstract contract IdentityTrick is Identity {}\r\n"
    },
    "contracts/_testContracts/IdentityTrick2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"@onchain-id/solidity/contracts/ClaimIssuer.sol\";\r\n\r\nabstract contract IdentityTrick2 is ClaimIssuer {}\r\n"
    },
    "contracts/compliance/BasicCompliance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"./interface/ICompliance.sol\";\r\nimport \"../token/IToken.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\n\r\ncontract BasicCompliance is ICompliance, AccessControl {\r\n    /// Mapping between agents and their statuses\r\n    mapping(address => bool) private _tokenAgentsList;\r\n    /// Mapping of tokens linked to the compliance contract\r\n    IToken public tokenBound;\r\n\r\n    // keccak256(ADMIN_ROLE)\r\n    bytes32 public constant ADMIN_ROLE =\r\n        0xa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775;\r\n\r\n    // keccak256(TOKEN_ROLE)\r\n    bytes32 public constant TOKEN_ROLE =\r\n        0xa7197c38d9c4c7450c7f2cd20d0a17cbe7c344190d6c82a6b49a146e62439ae4;\r\n\r\n    constructor() {\r\n        _grantRole(0x00, _msgSender());\r\n        _grantRole(ADMIN_ROLE, _msgSender());\r\n    }\r\n\r\n    /**\r\n     *  @dev See {ICompliance-bindToken}.\r\n     */\r\n    function bindToken(address _token) external {\r\n        require(\r\n            hasRole(ADMIN_ROLE, _msgSender()) ||\r\n                address(tokenBound) == address(0),\r\n            \"ERC-3643: Caller not authorized\"\r\n        );\r\n        tokenBound = IToken(_token);\r\n        emit TokenBound(_token);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {ICompliance-unbindToken}.\r\n     */\r\n    function unbindToken(address _token) external {\r\n        require(\r\n            hasRole(ADMIN_ROLE, _msgSender()) ||\r\n                hasRole(TOKEN_ROLE, _msgSender()),\r\n            \"ERC-3643: Caller not authorized\"\r\n        );\r\n        require(_token == address(tokenBound), \"ERC-3643: Token not bound\");\r\n        delete tokenBound;\r\n        emit TokenUnbound(_token);\r\n    }\r\n\r\n    /*\r\n     *  @dev See {ICompliance-transferred}.\r\n     */\r\n    function transferred(address _from, address _to, uint256 _value) external {}\r\n\r\n    /**\r\n     *  @dev See {ICompliance-created}.\r\n     */\r\n\r\n    function created(address _to, uint256 _value) external {}\r\n\r\n    /**\r\n     *  @dev See {ICompliance-destroyed}.\r\n     */\r\n    function destroyed(address _from, uint256 _value) external {}\r\n\r\n    /**\r\n     *  @dev See {ICompliance-canTransfer}.\r\n     */\r\n    function canTransfer(\r\n        address /*_from*/,\r\n        address /*_to*/,\r\n        uint256 /*_value*/\r\n    ) external view returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  @dev See {ICompliance-isTokenBound}.\r\n     */\r\n    function isTokenBound(address _token) external view returns (bool) {\r\n        return (_token == address(tokenBound));\r\n    }\r\n}\r\n"
    },
    "contracts/compliance/interface/ICompliance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\ninterface ICompliance {\r\n    /**\r\n     *  this event is emitted when a token has been bound to the compliance contract\r\n     *  the event is emitted by the bindToken function\r\n     *  `_token` is the address of the token to bind\r\n     */\r\n    event TokenBound(address _token);\r\n\r\n    /**\r\n     *  this event is emitted when a token has been unbound from the compliance contract\r\n     *  the event is emitted by the unbindToken function\r\n     *  `_token` is the address of the token to unbind\r\n     */\r\n    event TokenUnbound(address _token);\r\n\r\n    /**\r\n     *  @dev binds a token to the compliance contract\r\n     *  @param _token address of the token to bind\r\n     *  Emits a TokenBound event\r\n     */\r\n    function bindToken(address _token) external;\r\n\r\n    /**\r\n     *  @dev unbinds a token from the compliance contract\r\n     *  @param _token address of the token to unbind\r\n     *  Emits a TokenUnbound event\r\n     */\r\n    function unbindToken(address _token) external;\r\n\r\n    /**\r\n     *  @dev function called whenever tokens are transferred\r\n     *  from one wallet to another\r\n     *  this function can update state variables in the compliance contract\r\n     *  these state variables being used by `canTransfer` to decide if a transfer\r\n     *  is compliant or not depending on the values stored in these state variables and on\r\n     *  the parameters of the compliance smart contract\r\n     *  @param _from The address of the sender\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function transferred(address _from, address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev function called whenever tokens are created\r\n     *  on a wallet\r\n     *  this function can update state variables in the compliance contract\r\n     *  these state variables being used by `canTransfer` to decide if a transfer\r\n     *  is compliant or not depending on the values stored in these state variables and on\r\n     *  the parameters of the compliance smart contract\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function created(address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev function called whenever tokens are destroyed\r\n     *  this function can update state variables in the compliance contract\r\n     *  these state variables being used by `canTransfer` to decide if a transfer\r\n     *  is compliant or not depending on the values stored in these state variables and on\r\n     *  the parameters of the compliance smart contract\r\n     *  @param _from The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function destroyed(address _from, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev Returns true if the address given corresponds to a token that is bound with the Compliance contract\r\n     *  @param _token address of the token\r\n     */\r\n    function isTokenBound(address _token) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev checks that the transfer is compliant.\r\n     *  default compliance always returns true\r\n     *  READ ONLY FUNCTION, this function cannot be used to increment\r\n     *  counters, emit events, ...\r\n     *  @param _from The address of the sender\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function canTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external view returns (bool);\r\n}\r\n"
    },
    "contracts/registry/ClaimIssuersRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"@onchain-id/solidity/contracts/interface/IClaimIssuer.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./interface/IClaimIssuersRegistry.sol\";\r\n\r\n/// @title ERC-3643 - ClaimIssuersRegistry\r\n/// @dev This contract maintains a registry of claim issuers and their associated claim topics for the ERC-3643 standard.\r\ncontract ClaimIssuersRegistry is IClaimIssuersRegistry, Ownable {\r\n    /// @dev Array containing all ClaimIssuers identity contract address.\r\n    IClaimIssuer[] private _claimIssuers;\r\n\r\n    /// @dev Mapping between a claim issuer address and its corresponding claimTopics.\r\n    mapping(IClaimIssuer => uint256[]) private _claimIssuerClaimTopics;\r\n\r\n    /// @dev Mapping between a claim topic and the allowed claim issuers for it.\r\n    mapping(uint256 => IClaimIssuer[]) private _claimTopicToClaimIssuers;\r\n\r\n    /// @notice Adds a claim issuer to the Claim Issuers Registry.\r\n    /// @param _claimIssuer The address of the claim issuer.\r\n    /// @param _claimTopics An array of claim topics associated with the claim issuer.\r\n    /// Requirements:\r\n    /// - The caller must be the owner of the contract.\r\n    /// - The claim issuer address must not be zero.\r\n    /// - The claim issuer must not already exist in the registry.\r\n    /// - The claim topics array must not be empty.\r\n    /// - It is recommended to add a reasonable number of claim issuers at once.\r\n    /// Emits a ClaimIssuerAdded event.\r\n    function addClaimIssuer(\r\n        IClaimIssuer _claimIssuer,\r\n        uint256[] calldata _claimTopics\r\n    ) external onlyOwner {\r\n        require(\r\n            address(_claimIssuer) != address(0),\r\n            \"ERC-3643: Invalid zero address\"\r\n        );\r\n        require(\r\n            _claimIssuerClaimTopics[_claimIssuer].length == 0,\r\n            \"ERC-3643: Issuer already exists\"\r\n        );\r\n        uint length = _claimTopics.length;\r\n        require(length != 0, \"ERC-3643: Empty claim topics\");\r\n\r\n        _claimIssuers.push(_claimIssuer);\r\n        _claimIssuerClaimTopics[_claimIssuer] = _claimTopics;\r\n\r\n        for (uint256 i = 0; i < length; ) {\r\n            _claimTopicToClaimIssuers[_claimTopics[i]].push(_claimIssuer);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        emit ClaimIssuerAdded(_claimIssuer, _claimTopics);\r\n    }\r\n\r\n    /// @notice Removes a claim issuer from the Claim Issuers Registry.\r\n    /// @param _claimIssuer The address of the claim issuer to be removed.\r\n    /// Requirements:\r\n    /// - The caller must be the owner of the contract.\r\n    /// - The claim issuer must exist in the registry.\r\n    /// Emits a ClaimIssuerRemoved event.\r\n    function removeClaimIssuer(IClaimIssuer _claimIssuer) external onlyOwner {\r\n        uint claimIssuerTopicsLength = _claimIssuerClaimTopics[_claimIssuer]\r\n            .length;\r\n        require(claimIssuerTopicsLength != 0, \"ERC-3643: Not a claim issuer\");\r\n        uint256 claimIssuerlength = _claimIssuers.length;\r\n        for (uint256 i = 0; i < claimIssuerlength; ) {\r\n            if (_claimIssuers[i] == _claimIssuer) {\r\n                _claimIssuers[i] = _claimIssuers[claimIssuerlength - 1];\r\n                _claimIssuers.pop();\r\n                break;\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        _removeClaimIssuerFromAllClaimTopics(\r\n            _claimIssuer,\r\n            claimIssuerTopicsLength\r\n        );\r\n\r\n        delete _claimIssuerClaimTopics[_claimIssuer];\r\n        emit ClaimIssuerRemoved(_claimIssuer);\r\n    }\r\n\r\n    /// @notice Updates the claim topics associated with a claim issuer.\r\n    /// @param _claimIssuer The address of the claim issuer.\r\n    /// @param _claimTopics An array of claim topics to be associated with the claim issuer.\r\n    /// Requirements:\r\n    /// - The caller must be the owner of the contract.\r\n    /// - The claim issuer must exist in the registry.\r\n    /// - The claim topics array must not be empty.\r\n    /// Emits a ClaimTopicsUpdated event.\r\n    function updateIssuerClaimTopics(\r\n        IClaimIssuer _claimIssuer,\r\n        uint256[] calldata _claimTopics\r\n    ) external onlyOwner {\r\n        require(_claimTopics.length != 0, \"ERC-3643: No claim topics\");\r\n        uint claimIssuerTopicsLength = _claimIssuerClaimTopics[_claimIssuer]\r\n            .length;\r\n        require(claimIssuerTopicsLength != 0, \"ERC-3643: Not a claim issuer\");\r\n\r\n        _updateIssuerAcrossAllTopics(_claimIssuer);\r\n\r\n        _claimIssuerClaimTopics[_claimIssuer] = _claimTopics;\r\n\r\n        emit ClaimTopicsUpdated(_claimIssuer, _claimTopics);\r\n    }\r\n\r\n    /// @notice Returns an array of all claim issuers in the registry.\r\n    /// @return A memory array of claim issuers.\r\n    function getClaimIssuers() external view returns (IClaimIssuer[] memory) {\r\n        return _claimIssuers;\r\n    }\r\n\r\n    /// @notice Returns an array of all claim issuers associated with a specific claim topic.\r\n    /// @param claimTopic The claim topic to find associated claim issuers for.\r\n    /// @return A memory array of claim issuers.\r\n    function getClaimIssuersForClaimTopic(\r\n        uint256 claimTopic\r\n    ) external view returns (IClaimIssuer[] memory) {\r\n        return _claimTopicToClaimIssuers[claimTopic];\r\n    }\r\n\r\n    /// @notice Checks if an address is a claim issuer in the registry.\r\n    /// @param _issuer The address to check.\r\n    /// @return True if the address is a claim issuer, false otherwise.\r\n    function isClaimIssuer(IClaimIssuer _issuer) external view returns (bool) {\r\n        return _isClaimIssuer(_issuer);\r\n    }\r\n\r\n    /// @notice Returns an array of claim topics associated with a specific claim issuer.\r\n    /// @param _claimIssuer The claim issuer to find associated claim topics for.\r\n    /// @return A memory array of claim topics.\r\n    function getClaimIssuerClaimTopics(\r\n        IClaimIssuer _claimIssuer\r\n    ) external view returns (uint256[] memory) {\r\n        require(_isClaimIssuer(_claimIssuer), \"ERC-3643: Issuer doesn't exist\");\r\n        return _claimIssuerClaimTopics[_claimIssuer];\r\n    }\r\n\r\n    /// @notice Checks if a claim issuer has a specific claim topic.\r\n    /// @dev This function checks if a specific claim topic is associated with a claim issuer.\r\n    /// @param _issuer The claim issuer to check.\r\n    /// @param _claimTopic The claim topic to check.\r\n    /// @return bool True if the claim issuer has the claim topic, otherwise false.\r\n    function hasClaimTopic(\r\n        IClaimIssuer _issuer,\r\n        uint256 _claimTopic\r\n    ) external view returns (bool) {\r\n        uint256 length = _claimIssuerClaimTopics[_issuer].length;\r\n        uint256[] memory claimTopics = _claimIssuerClaimTopics[_issuer];\r\n        for (uint256 i = 0; i < length; ) {\r\n            if (claimTopics[i] == _claimTopic) {\r\n                return true;\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Removes a claim issuer from all associated claim topics.\r\n    /// @param claimIssuer The claim issuer to be removed.\r\n    /// @param length The number of claim topics associated with the claim issuer.\r\n    function _removeClaimIssuerFromAllClaimTopics(\r\n        IClaimIssuer claimIssuer,\r\n        uint length\r\n    ) private {\r\n        for (uint256 i = 0; i < length; ) {\r\n            uint256 claimTopic = _claimIssuerClaimTopics[claimIssuer][i];\r\n\r\n            _removeIssuerFromTopic(claimIssuer, claimTopic);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Updates a claim issuer across all associated claim topics.\r\n    ///      The function removes the claim issuer from each topic, and then adds it back.\r\n    /// @param claimIssuer The claim issuer to be updated.\r\n    function _updateIssuerAcrossAllTopics(IClaimIssuer claimIssuer) private {\r\n        uint256[] memory claimTopics = _claimIssuerClaimTopics[claimIssuer];\r\n        uint length = claimTopics.length;\r\n\r\n        for (uint256 i = 0; i < length; ) {\r\n            uint256 claimTopic = claimTopics[i];\r\n\r\n            _removeIssuerFromTopic(claimIssuer, claimTopic);\r\n            _claimTopicToClaimIssuers[claimTopics[i]].push(claimIssuer);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Removes a claim issuer from a specific claim topic.\r\n    ///      The function identifies and replaces the claim issuer with the last element in the list\r\n    ///      then removes the last element, effectively removing the issuer from the list.\r\n    /// @param claimIssuer The claim issuer to be removed.\r\n    /// @param claimTopic The claim topic identifier from which the issuer is to be removed.\r\n    function _removeIssuerFromTopic(\r\n        IClaimIssuer claimIssuer,\r\n        uint claimTopic\r\n    ) private {\r\n        IClaimIssuer[] memory claimIssuers = _claimTopicToClaimIssuers[\r\n            claimTopic\r\n        ];\r\n        uint length = claimIssuers.length;\r\n\r\n        for (uint j = 0; j < length; ) {\r\n            if (claimIssuers[j] == claimIssuer) {\r\n                _claimTopicToClaimIssuers[claimTopic][j] = claimIssuers[\r\n                    length - 1\r\n                ];\r\n                _claimTopicToClaimIssuers[claimTopic].pop();\r\n                break;\r\n            }\r\n            unchecked {\r\n                ++j;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Checks if an address is a claim issuer.\r\n    /// @param _issuer The address to check.\r\n    /// @return bool Returns true if the address is a claim issuer, and false otherwise.\r\n    function _isClaimIssuer(IClaimIssuer _issuer) private view returns (bool) {\r\n        return (_claimIssuerClaimTopics[_issuer].length != 0);\r\n    }\r\n}\r\n"
    },
    "contracts/registry/ClaimTopicsRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./interface/IClaimTopicsRegistry.sol\";\r\n\r\n/// @title ERC-3643 - ClaimTopicsRegistry\r\n/// @dev A registry for managing claim topics.\r\ncontract ClaimTopicsRegistry is IClaimTopicsRegistry, Ownable {\r\n    /// @dev An array to hold all required claim topics.\r\n    uint256[] private _claimTopics;\r\n\r\n    /// @notice Adds a claim topic to the registry.\r\n    /// @dev Can only be called by the owner of the contract.\r\n    /// Emits a ClaimTopicAdded event.\r\n    /// @param _claimTopic The claim topic to add.\r\n    function addClaimTopic(uint256 _claimTopic) external onlyOwner {\r\n        require(_isClaimTopicUnique(_claimTopic), \"ERC-3643: Topic exists\");\r\n\r\n        _claimTopics.push(_claimTopic);\r\n        emit ClaimTopicAdded(_claimTopic);\r\n    }\r\n\r\n    /// @notice Removes a claim topic from the registry.\r\n    /// @dev Can only be called by the owner of the contract.\r\n    /// Emits a ClaimTopicRemoved event.\r\n    /// @param _claimTopic The claim topic to remove.\r\n    function removeClaimTopic(uint256 _claimTopic) external onlyOwner {\r\n        uint256 length = _claimTopics.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (_claimTopics[i] == _claimTopic) {\r\n                _claimTopics[i] = _claimTopics[length - 1];\r\n                _claimTopics.pop();\r\n                emit ClaimTopicRemoved(_claimTopic);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Retrieves all claim topics from the registry.\r\n    /// @return uint256[] An array of claim topics.\r\n    function getClaimTopics() external view returns (uint256[] memory) {\r\n        return _claimTopics;\r\n    }\r\n\r\n    /// @notice Checks if a claim topic is unique in the registry.\r\n    /// @dev Private function to check the uniqueness of a claim topic.\r\n    /// @param claimTopic The claim topic to check.\r\n    /// @return bool True if the claim topic is unique, false otherwise.\r\n    function _isClaimTopicUnique(\r\n        uint256 claimTopic\r\n    ) private view returns (bool) {\r\n        uint256[] memory claimTopics = _claimTopics;\r\n        uint256 length = _claimTopics.length;\r\n        for (uint256 i = 0; i < length; ) {\r\n            if (claimTopics[i] == claimTopic) {\r\n                return false;\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/registry/IdentityRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"@onchain-id/solidity/contracts/interface/IClaimIssuer.sol\";\r\nimport \"@onchain-id/solidity/contracts/interface/IIdentity.sol\";\r\nimport \"./interface/IClaimTopicsRegistry.sol\";\r\nimport \"./interface/IClaimIssuersRegistry.sol\";\r\nimport \"./interface/IIdentityRegistry.sol\";\r\nimport \"./interface/IIdentityRegistryStorage.sol\";\r\n\r\n/// @title ERC-3643 - IdentityRegistry\r\n/// @dev This contract is used to manage identities in the ERC-3643 standard.\r\n/// It allows for the registration, updating and deletion of identities associated with user addresses.\r\n/// It also supports the management of claim topics and claim issuers.\r\ncontract IdentityRegistry is IIdentityRegistry, AccessControl {\r\n    /// @notice The address of the ClaimTopicsRegistry contract.\r\n    IClaimTopicsRegistry private _tokenTopicsRegistry;\r\n\r\n    /// @notice The address of the ClaimIssuersRegistry contract.\r\n    IClaimIssuersRegistry private _tokenIssuersRegistry;\r\n\r\n    /// @notice The address of the IdentityRegistryStorage contract.\r\n    IIdentityRegistryStorage private _tokenIdentityStorage;\r\n\r\n    // keccak256(AGENT_ROLE)\r\n    bytes32 public constant AGENT_ROLE =\r\n        0xcab5a0bfe0b79d2c4b1c2e02599fa044d115b7511f9659307cb4276950967709;\r\n\r\n    // keccak256(OWNER_ROLE)\r\n    bytes32 public constant OWNER_ROLE =\r\n        0xb19546dff01e856fb3f010c267a7b1c60363cf8a4664e21cc89c26224620214e;\r\n\r\n    /// @dev Constructor of the IdentityRegistry contract.\r\n    /// @param _claimIssuersRegistry The address of the claim issuers registry contract.\r\n    /// @param _claimTopicsRegistry The address of the claim topics registry contract.\r\n    /// @param _identityStorage The address of the identity registry storage contract.\r\n    /// @notice This constructor sets the initial state of the IdentityRegistry contract.\r\n    constructor(\r\n        IClaimIssuersRegistry _claimIssuersRegistry,\r\n        IClaimTopicsRegistry _claimTopicsRegistry,\r\n        IIdentityRegistryStorage _identityStorage\r\n    ) {\r\n        require(\r\n            address(_claimIssuersRegistry) != address(0) &&\r\n                address(_claimTopicsRegistry) != address(0) &&\r\n                address(_identityStorage) != address(0),\r\n            \"ERC-3643: Invalid zero address\"\r\n        );\r\n        _grantRole(bytes32(0), _msgSender());\r\n        _grantRole(OWNER_ROLE, _msgSender());\r\n        _tokenTopicsRegistry = _claimTopicsRegistry;\r\n        _tokenIssuersRegistry = _claimIssuersRegistry;\r\n        _tokenIdentityStorage = _identityStorage;\r\n        emit ClaimTopicsRegistrySet(_claimTopicsRegistry);\r\n        emit ClaimIssuersRegistrySet(_claimIssuersRegistry);\r\n        emit IdentityStorageSet(_identityStorage);\r\n    }\r\n\r\n    /// @notice Register an identity associated with a user address.\r\n    /// @param _userAddress The address of the user.\r\n    /// @param _identity The identity of the user.\r\n    /// @param _country The country code of the user.\r\n    /// @dev Only an agent can register an identity.\r\n    function registerIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        _registerIdentity(_userAddress, _identity, _country);\r\n    }\r\n\r\n    /// @notice Register multiple identities associated with multiple user addresses.\r\n    /// @param _userAddresses The array of user addresses.\r\n    /// @param _identities The array of identities.\r\n    /// @param _countries The array of country codes.\r\n    /// @dev Only an agent can register identities in batch.\r\n    function batchRegisterIdentity(\r\n        address[] calldata _userAddresses,\r\n        IIdentity[] calldata _identities,\r\n        uint16[] calldata _countries\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        uint length = _userAddresses.length;\r\n        require(length == _identities.length, \"ERC-3643: Array size mismatch\");\r\n        require(length == _countries.length, \"ERC-3643: Array size mismatch\");\r\n        for (uint256 i = 0; i < length; ) {\r\n            _registerIdentity(_userAddresses[i], _identities[i], _countries[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Update the identity associated with a user address.\r\n    /// @param _userAddress The address of the user.\r\n    /// @param _identity The new identity of the user.\r\n    /// @dev Only an agent can update an identity.\r\n    function updateIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        IIdentity oldIdentity = _getIdentity(_userAddress);\r\n        _tokenIdentityStorage.modifyStoredIdentity(_userAddress, _identity);\r\n        emit IdentityUpdated(oldIdentity, _identity);\r\n    }\r\n\r\n    /// @notice Update the country code associated with a user address.\r\n    /// @param _userAddress The address of the user.\r\n    /// @param _country The new country code of the user.\r\n    /// @dev Only an agent can update a country code.\r\n    function updateCountry(\r\n        address _userAddress,\r\n        uint16 _country\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        _tokenIdentityStorage.modifyStoredInvestorCountry(\r\n            _userAddress,\r\n            _country\r\n        );\r\n        emit CountryUpdated(_userAddress, _country);\r\n    }\r\n\r\n    /// @notice Delete the identity associated with a user address.\r\n    /// @param _userAddress The address of the user.\r\n    /// @dev Only an agent can delete an identity.\r\n    function deleteIdentity(\r\n        address _userAddress\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        IIdentity oldIdentity = _getIdentity(_userAddress);\r\n        _tokenIdentityStorage.removeIdentityFromStorage(_userAddress);\r\n        emit IdentityRemoved(_userAddress, oldIdentity);\r\n    }\r\n\r\n    /// @notice Set the IdentityRegistryStorage contract.\r\n    /// @param _identityRegistryStorage The address of the new IdentityRegistryStorage contract.\r\n    /// @dev Only the owner can set the IdentityRegistryStorage contract.\r\n    function setIdentityRegistryStorage(\r\n        IIdentityRegistryStorage _identityRegistryStorage\r\n    ) external onlyRole(OWNER_ROLE) {\r\n        _tokenIdentityStorage = _identityRegistryStorage;\r\n        emit IdentityStorageSet(_identityRegistryStorage);\r\n    }\r\n\r\n    /// @notice Set the ClaimTopicsRegistry contract.\r\n    /// @param _claimTopicsRegistry The address of the new ClaimTopicsRegistry contract.\r\n    /// @dev Only the owner can set the ClaimTopicsRegistry contract.\r\n    function setClaimTopicsRegistry(\r\n        IClaimTopicsRegistry _claimTopicsRegistry\r\n    ) external onlyRole(OWNER_ROLE) {\r\n        _tokenTopicsRegistry = _claimTopicsRegistry;\r\n        emit ClaimTopicsRegistrySet(_claimTopicsRegistry);\r\n    }\r\n\r\n    /// @notice Set the ClaimIssuersRegistry contract.\r\n    /// @param _claimIssuersRegistry The address of the new ClaimIssuersRegistry contract.\r\n    /// @dev Only the owner can set the ClaimIssuersRegistry contract.\r\n    function setClaimIssuersRegistry(\r\n        IClaimIssuersRegistry _claimIssuersRegistry\r\n    ) external onlyRole(OWNER_ROLE) {\r\n        _tokenIssuersRegistry = _claimIssuersRegistry;\r\n        emit ClaimIssuersRegistrySet(_claimIssuersRegistry);\r\n    }\r\n\r\n    /// @notice Checks if a user is verified based on their identity, claim topics, and claim issuers.\r\n    /// @param _userAddress The address of the user to check.\r\n    /// @return A boolean indicating if the user is verified.\r\n    function isVerified(address _userAddress) external view returns (bool) {\r\n        // Get the identity of the user from the given address\r\n        IIdentity userIdentity = _getIdentity(_userAddress);\r\n\r\n        // If the user identity is not set (address is 0), return false\r\n        if (address(userIdentity) == address(0)) return false;\r\n\r\n        // Get the required claim topics for the token\r\n        uint256[] memory claimTopics = _tokenTopicsRegistry.getClaimTopics();\r\n        uint claimTopicsLength = claimTopics.length;\r\n\r\n        // If there are no required claim topics, return true\r\n        if (claimTopicsLength == 0) return true;\r\n\r\n        // Loop over all required claim topics\r\n        for (uint256 i = 0; i < claimTopicsLength; i++) {\r\n            if (!_isClaimValid(userIdentity, claimTopics[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        // If all checks pass, return true\r\n        return true;\r\n    }\r\n\r\n    /// @notice Get the country of an investor.\r\n    /// @param _userAddress The address of the investor.\r\n    /// @return The country of the investor.\r\n    function investorCountry(\r\n        address _userAddress\r\n    ) external view returns (uint16) {\r\n        return _tokenIdentityStorage.storedInvestorCountry(_userAddress);\r\n    }\r\n\r\n    /// @notice Get the issuers registry.\r\n    /// @return The current issuers registry.\r\n    function issuersRegistry() external view returns (IClaimIssuersRegistry) {\r\n        return _tokenIssuersRegistry;\r\n    }\r\n\r\n    /// @notice Get the topics registry.\r\n    /// @return The current topics registry.\r\n    function topicsRegistry() external view returns (IClaimTopicsRegistry) {\r\n        return _tokenTopicsRegistry;\r\n    }\r\n\r\n    /// @notice Get the identity storage.\r\n    /// @return The current identity storage.\r\n    function identityStorage()\r\n        external\r\n        view\r\n        returns (IIdentityRegistryStorage)\r\n    {\r\n        return _tokenIdentityStorage;\r\n    }\r\n\r\n    /// @notice Check if an address is contained in the registry.\r\n    /// @param _userAddress The address to check.\r\n    /// @return A boolean indicating if the address is in the registry.\r\n    function contains(address _userAddress) external view returns (bool) {\r\n        return address(identity(_userAddress)) == address(0) ? false : true;\r\n    }\r\n\r\n    /// @notice Get the identity of a user.\r\n    /// @param _userAddress The address of the user.\r\n    /// @return The identity of the user.\r\n    function identity(address _userAddress) public view returns (IIdentity) {\r\n        return _tokenIdentityStorage.storedIdentity(_userAddress);\r\n    }\r\n\r\n    /// @notice Register a new identity.\r\n    /// @param _userAddress The address of the user.\r\n    /// @param _identity The identity of the user.\r\n    /// @param _country The country of the user.\r\n    function _registerIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) private {\r\n        _tokenIdentityStorage.addIdentityToStorage(\r\n            _userAddress,\r\n            _identity,\r\n            _country\r\n        );\r\n        emit IdentityRegistered(_userAddress, _identity);\r\n    }\r\n\r\n    /// @notice Get the identity of a user.\r\n    /// @param _userAddress The address of the user.\r\n    /// @return The identity of the user.\r\n    function _getIdentity(\r\n        address _userAddress\r\n    ) private view returns (IIdentity) {\r\n        return _tokenIdentityStorage.storedIdentity(_userAddress);\r\n    }\r\n\r\n    function _isClaimValid(\r\n        IIdentity userIdentity,\r\n        uint256 claimTopic\r\n    ) private view returns (bool) {\r\n        IClaimIssuer[] memory claimIssuers = _tokenIssuersRegistry\r\n            .getClaimIssuersForClaimTopic(claimTopic);\r\n        uint claimIssuersLength = claimIssuers.length;\r\n\r\n        if (claimIssuersLength == 0) {\r\n            return false;\r\n        }\r\n\r\n        bytes32[] memory claimIds = new bytes32[](claimIssuersLength);\r\n\r\n        for (uint256 i = 0; i < claimIssuersLength; i++) {\r\n            claimIds[i] = keccak256(abi.encode(claimIssuers[i], claimTopic));\r\n        }\r\n\r\n        for (uint256 j = 0; j < claimIds.length; j++) {\r\n            (\r\n                uint256 foundClaimTopic,\r\n                ,\r\n                address issuer,\r\n                bytes memory sig,\r\n                bytes memory data,\r\n\r\n            ) = userIdentity.getClaim(claimIds[j]);\r\n\r\n            if (foundClaimTopic == claimTopic) {\r\n                if (\r\n                    _isIssuerClaimValid(\r\n                        userIdentity,\r\n                        issuer,\r\n                        claimTopic,\r\n                        sig,\r\n                        data\r\n                    )\r\n                ) {\r\n                    return true;\r\n                }\r\n            } else if (j == claimIds.length - 1) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @param userIdentity The identity contract related to the claim.\r\n    /// @param issuer The address of the claim issuer.\r\n    /// @param claimTopic The claim topic of the claim.\r\n    /// @param sig The signature of the claim.\r\n    /// @param data The data field of the claim.\r\n    /// @return claimValid True if the claim is valid, false otherwise.\r\n    function _isIssuerClaimValid(\r\n        IIdentity userIdentity,\r\n        address issuer,\r\n        uint claimTopic,\r\n        bytes memory sig,\r\n        bytes memory data\r\n    ) private view returns (bool) {\r\n        try\r\n            IClaimIssuer(issuer).isClaimValid(\r\n                userIdentity,\r\n                claimTopic,\r\n                sig,\r\n                data\r\n            )\r\n        returns (bool _validity) {\r\n            return _validity;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/registry/IdentityRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"@onchain-id/solidity/contracts/interface/IIdentity.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\n\r\nimport \"./interface/IIdentityRegistryStorage.sol\";\r\n\r\n/// @title ERC-3643 - IdentityRegistryStorage\r\n/// @notice Stores user identities and their respective countries.\r\ncontract IdentityRegistryStorage is IIdentityRegistryStorage, AccessControl {\r\n    /// @dev struct containing the identity contract and the country of the user\r\n    struct Identity {\r\n        /// @dev Identity contract of the user\r\n        IIdentity identityContract;\r\n        /// @dev Country of the user\r\n        uint16 investorCountry;\r\n    }\r\n\r\n    // keccak256(AGENT_ROLE)\r\n    bytes32 public constant AGENT_ROLE =\r\n        0xcab5a0bfe0b79d2c4b1c2e02599fa044d115b7511f9659307cb4276950967709;\r\n\r\n    // keccak256(OWNER_ROLE)\r\n    bytes32 public constant OWNER_ROLE =\r\n        0xb19546dff01e856fb3f010c267a7b1c60363cf8a4664e21cc89c26224620214e;\r\n\r\n    /// @dev Mapping between a user address and the corresponding identity\r\n    mapping(address => Identity) internal _identities;\r\n\r\n    /// @dev Array of Identity Registries linked to this storage\r\n    address[] internal _identityRegistries;\r\n\r\n    constructor() {\r\n        _grantRole(bytes32(0), _msgSender());\r\n        _grantRole(AGENT_ROLE, _msgSender());\r\n        _grantRole(OWNER_ROLE, _msgSender());\r\n    }\r\n\r\n    /// @notice Adds a new identity to the storage\r\n    /// @param _userAddress User's address\r\n    /// @param _identity Identity contract of the user\r\n    /// @param _country Country of the user\r\n    function addIdentityToStorage(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        require(\r\n            _userAddress != address(0) && address(_identity) != address(0),\r\n            \"ERC-3643: Invalid zero address\"\r\n        );\r\n        require(\r\n            address(_identities[_userAddress].identityContract) == address(0),\r\n            \"ERC-3643: Already stored\"\r\n        );\r\n        _identities[_userAddress].identityContract = _identity;\r\n        _identities[_userAddress].investorCountry = _country;\r\n        emit IdentityStored(_userAddress, _identity);\r\n    }\r\n\r\n    /// @notice Modifies the stored identity of a user\r\n    /// @param _userAddress User's address\r\n    /// @param _identity New identity contract of the user\r\n    function modifyStoredIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        require(\r\n            _userAddress != address(0) && address(_identity) != address(0),\r\n            \"ERC-3643: Invalid zero address\"\r\n        );\r\n        require(\r\n            address(_identities[_userAddress].identityContract) != address(0),\r\n            \"ERC-3643: Address not stored\"\r\n        );\r\n        IIdentity oldIdentity = _identities[_userAddress].identityContract;\r\n        _identities[_userAddress].identityContract = _identity;\r\n        emit IdentityModified(oldIdentity, _identity);\r\n    }\r\n\r\n    /// @notice Modifies the stored investor country of a user\r\n    /// @param _userAddress User's address\r\n    /// @param _country New country of the user\r\n    function modifyStoredInvestorCountry(\r\n        address _userAddress,\r\n        uint16 _country\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        require(_userAddress != address(0), \"ERC-3643: Invalid zero address\");\r\n        require(\r\n            address(_identities[_userAddress].identityContract) != address(0),\r\n            \"ERC-3643: Address not stored\"\r\n        );\r\n        _identities[_userAddress].investorCountry = _country;\r\n        emit CountryModified(_userAddress, _country);\r\n    }\r\n\r\n    /// @notice Removes a user identity from the storage\r\n    /// @param _userAddress User's address\r\n    function removeIdentityFromStorage(\r\n        address _userAddress\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        require(_userAddress != address(0), \"ERC-3643: Invalid zero address\");\r\n        require(\r\n            address(_identities[_userAddress].identityContract) != address(0),\r\n            \"ERC-3643: Address not stored\"\r\n        );\r\n        IIdentity oldIdentity = _identities[_userAddress].identityContract;\r\n        delete _identities[_userAddress];\r\n        emit IdentityUnstored(_userAddress, oldIdentity);\r\n    }\r\n\r\n    /// @notice Links an identity registry to this storage\r\n    /// @param _identityRegistry Address of the identity registry\r\n    function bindIdentityRegistry(\r\n        address _identityRegistry\r\n    ) external onlyRole(OWNER_ROLE) {\r\n        require(\r\n            _identityRegistry != address(0),\r\n            \"ERC-3643: Invalid zero address\"\r\n        );\r\n        _grantRole(AGENT_ROLE, _identityRegistry);\r\n        _identityRegistries.push(_identityRegistry);\r\n        emit IdentityRegistryBound(_identityRegistry);\r\n    }\r\n\r\n    /// @notice Unlinks an identity registry from this storage\r\n    /// @param _identityRegistry Address of the identity registry\r\n    function unbindIdentityRegistry(\r\n        address _identityRegistry\r\n    ) external onlyRole(OWNER_ROLE) {\r\n        require(\r\n            _identityRegistry != address(0),\r\n            \"ERC-3643: Invalid zero address\"\r\n        );\r\n        require(\r\n            _identityRegistries.length != 0,\r\n            \"ERC-3643: No identity registry\"\r\n        );\r\n        uint256 length = _identityRegistries.length;\r\n        for (uint256 i = 0; i < length; ) {\r\n            if (_identityRegistries[i] == _identityRegistry) {\r\n                _identityRegistries[i] = _identityRegistries[length - 1];\r\n                _identityRegistries.pop();\r\n                break;\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        _revokeRole(AGENT_ROLE, _identityRegistry);\r\n        emit IdentityRegistryUnbound(_identityRegistry);\r\n    }\r\n\r\n    /// @notice Returns all linked identity registries\r\n    /// @return Array of addresses of the linked identity registries\r\n    function linkedIdentityRegistries()\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return _identityRegistries;\r\n    }\r\n\r\n    /// @notice Returns the stored identity of a user\r\n    /// @param _userAddress User's address\r\n    /// @return User's identity contract\r\n    function storedIdentity(\r\n        address _userAddress\r\n    ) external view returns (IIdentity) {\r\n        return _identities[_userAddress].identityContract;\r\n    }\r\n\r\n    /// @notice Returns the stored investor country of a user\r\n    /// @param _userAddress User's address\r\n    /// @return User's country\r\n    function storedInvestorCountry(\r\n        address _userAddress\r\n    ) external view returns (uint16) {\r\n        return _identities[_userAddress].investorCountry;\r\n    }\r\n}\r\n"
    },
    "contracts/registry/interface/IClaimIssuersRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"@onchain-id/solidity/contracts/interface/IClaimIssuer.sol\";\r\n\r\ninterface IClaimIssuersRegistry {\r\n    /**\r\n     *  this event is emitted when a claim issuer is added in the registry.\r\n     *  the event is emitted by the addClaimIssuer function\r\n     *  `claimIssuer` is the address of the claim issuer's ClaimIssuer contract\r\n     *  `claimTopics` is the set of claims that the claim issuer is allowed to emit\r\n     */\r\n    event ClaimIssuerAdded(\r\n        IClaimIssuer indexed claimIssuer,\r\n        uint256[] claimTopics\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when a claim issuer is removed from the registry.\r\n     *  the event is emitted by the removeClaimIssuer function\r\n     *  `claimIssuer` is the address of the claim issuer's ClaimIssuer contract\r\n     */\r\n    event ClaimIssuerRemoved(IClaimIssuer indexed claimIssuer);\r\n\r\n    /**\r\n     *  this event is emitted when the set of claim topics is changed for a given claim issuer.\r\n     *  the event is emitted by the updateIssuerClaimTopics function\r\n     *  `claimIssuer` is the address of the claim issuer's ClaimIssuer contract\r\n     *  `claimTopics` is the set of claims that the claim issuer is allowed to emit\r\n     */\r\n    event ClaimTopicsUpdated(\r\n        IClaimIssuer indexed claimIssuer,\r\n        uint256[] claimTopics\r\n    );\r\n\r\n    /**\r\n     *  @dev registers a ClaimIssuer contract as claim claim issuer.\r\n     *  Requires that a ClaimIssuer contract doesn't already exist\r\n     *  Requires that the claimTopics set is not empty\r\n     *  Requires that there is no more than 15 claimTopics\r\n     *  Requires that there is no more than 50 Claim issuers\r\n     *  @param _claimIssuer The ClaimIssuer contract address of the claim claim issuer.\r\n     *  @param _claimTopics the set of claim topics that the claim issuer is allowed to emit\r\n     *  This function can only be called by the owner of the Claim Issuers Registry contract\r\n     *  emits a `ClaimIssuerAdded` event\r\n     */\r\n    function addClaimIssuer(\r\n        IClaimIssuer _claimIssuer,\r\n        uint256[] calldata _claimTopics\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Removes the ClaimIssuer contract of a claim claim issuer.\r\n     *  Requires that the claim issuer contract to be registered first\r\n     *  @param _claimIssuer the claim issuer to remove.\r\n     *  This function can only be called by the owner of the Claim Issuers Registry contract\r\n     *  emits a `ClaimIssuerRemoved` event\r\n     */\r\n    function removeClaimIssuer(IClaimIssuer _claimIssuer) external;\r\n\r\n    /**\r\n     *  @dev Updates the set of claim topics that a claim issuer is allowed to emit.\r\n     *  Requires that this ClaimIssuer contract already exists in the registry\r\n     *  Requires that the provided claimTopics set is not empty\r\n     *  Requires that there is no more than 15 claimTopics\r\n     *  @param _claimIssuer the claim issuer to update.\r\n     *  @param _claimTopics the set of claim topics that the claim issuer is allowed to emit\r\n     *  This function can only be called by the owner of the Claim Issuers Registry contract\r\n     *  emits a `ClaimTopicsUpdated` event\r\n     */\r\n    function updateIssuerClaimTopics(\r\n        IClaimIssuer _claimIssuer,\r\n        uint256[] calldata _claimTopics\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Function for getting all the claim claim issuers stored.\r\n     *  @return array of all claim issuers registered.\r\n     */\r\n    function getClaimIssuers() external view returns (IClaimIssuer[] memory);\r\n\r\n    /**\r\n     *  @dev Function for getting all the claim issuer allowed for a given claim topic.\r\n     *  @param claimTopic the claim topic to get the claim issuers for.\r\n     *  @return array of all claim issuer addresses that are allowed for the given claim topic.\r\n     */\r\n    function getClaimIssuersForClaimTopic(\r\n        uint256 claimTopic\r\n    ) external view returns (IClaimIssuer[] memory);\r\n\r\n    /**\r\n     *  @dev Checks if the ClaimIssuer contract is claim\r\n     *  @param _issuer the address of the ClaimIssuer contract\r\n     *  @return true if the issuer is claim, false otherwise.\r\n     */\r\n    function isClaimIssuer(IClaimIssuer _issuer) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Function for getting all the claim topic of claim claim issuer\r\n     *  Requires the provided ClaimIssuer contract to be registered in the claim issuers registry.\r\n     *  @param _claimIssuer the claim issuer concerned.\r\n     *  @return The set of claim topics that the claim issuer is allowed to emit\r\n     */\r\n    function getClaimIssuerClaimTopics(\r\n        IClaimIssuer _claimIssuer\r\n    ) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     *  @dev Function for checking if the claim claim issuer is allowed\r\n     *  to emit a certain claim topic\r\n     *  @param _issuer the address of the claim issuer's ClaimIssuer contract\r\n     *  @param _claimTopic the Claim Topic that has to be checked to know if the `issuer` is allowed to emit it\r\n     *  @return true if the issuer is claim for this claim topic.\r\n     */\r\n    function hasClaimTopic(\r\n        IClaimIssuer _issuer,\r\n        uint256 _claimTopic\r\n    ) external view returns (bool);\r\n}\r\n"
    },
    "contracts/registry/interface/IClaimTopicsRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\ninterface IClaimTopicsRegistry {\r\n    /**\r\n     *  this event is emitted when a claim topic has been added to the ClaimTopicsRegistry\r\n     *  the event is emitted by the 'addClaimTopic' function\r\n     *  `claimTopic` is the required claim added to the Claim Topics Registry\r\n     */\r\n    event ClaimTopicAdded(uint256 indexed claimTopic);\r\n\r\n    /**\r\n     *  this event is emitted when a claim topic has been removed from the ClaimTopicsRegistry\r\n     *  the event is emitted by the 'removeClaimTopic' function\r\n     *  `claimTopic` is the required claim removed from the Claim Topics Registry\r\n     */\r\n    event ClaimTopicRemoved(uint256 indexed claimTopic);\r\n\r\n    /**\r\n     * @dev Add a claim claim topic (For example: KYC=1, AML=2).\r\n     * Only owner can call.\r\n     * emits `ClaimTopicAdded` event\r\n     * cannot add more than 15 topics for 1 token as adding more could create gas issues\r\n     * @param _claimTopic The claim topic index\r\n     */\r\n    function addClaimTopic(uint256 _claimTopic) external;\r\n\r\n    /**\r\n     *  @dev Remove a claim claim topic (For example: KYC=1, AML=2).\r\n     *  Only owner can call.\r\n     *  emits `ClaimTopicRemoved` event\r\n     *  @param _claimTopic The claim topic index\r\n     */\r\n    function removeClaimTopic(uint256 _claimTopic) external;\r\n\r\n    /**\r\n     *  @dev Get the claim claim topics for the security token\r\n     *  @return Array of claim claim topics\r\n     */\r\n    function getClaimTopics() external view returns (uint256[] memory);\r\n}\r\n"
    },
    "contracts/registry/interface/IIdentityRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"./IClaimIssuersRegistry.sol\";\r\nimport \"./IClaimTopicsRegistry.sol\";\r\nimport \"./IIdentityRegistryStorage.sol\";\r\n\r\nimport \"@onchain-id/solidity/contracts/interface/IClaimIssuer.sol\";\r\nimport \"@onchain-id/solidity/contracts/interface/IIdentity.sol\";\r\n\r\ninterface IIdentityRegistry {\r\n    /**\r\n     *  this event is emitted when the ClaimTopicsRegistry has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `claimTopicsRegistry` is the address of the Claim Topics Registry contract\r\n     */\r\n    event ClaimTopicsRegistrySet(\r\n        IClaimTopicsRegistry indexed claimTopicsRegistry\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when the IdentityRegistryStorage has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `identityStorage` is the address of the Identity Registry Storage contract\r\n     */\r\n    event IdentityStorageSet(IIdentityRegistryStorage indexed identityStorage);\r\n\r\n    /**\r\n     *  this event is emitted when the ClaimIssuersRegistry has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `claimIssuersRegistry` is the address of the Claim Issuers Registry contract\r\n     */\r\n    event ClaimIssuersRegistrySet(\r\n        IClaimIssuersRegistry indexed claimIssuersRegistry\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is registered into the Identity Registry.\r\n     *  the event is emitted by the 'registerIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityRegistered(\r\n        address indexed investorAddress,\r\n        IIdentity indexed identity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is removed from the Identity Registry.\r\n     *  the event is emitted by the 'deleteIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityRemoved(\r\n        address indexed investorAddress,\r\n        IIdentity indexed identity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity has been updated\r\n     *  the event is emitted by the 'updateIdentity' function\r\n     *  `oldIdentity` is the old Identity contract's address to update\r\n     *  `newIdentity` is the new Identity contract's\r\n     */\r\n    event IdentityUpdated(\r\n        IIdentity indexed oldIdentity,\r\n        IIdentity indexed newIdentity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity's country has been updated\r\n     *  the event is emitted by the 'updateCountry' function\r\n     *  `investorAddress` is the address on which the country has been updated\r\n     *  `country` is the numeric code (ISO 3166-1) of the new country\r\n     */\r\n    event CountryUpdated(\r\n        address indexed investorAddress,\r\n        uint16 indexed country\r\n    );\r\n\r\n    /**\r\n     *  @dev Register an identity contract corresponding to a user address.\r\n     *  Requires that the user doesn't have an identity contract already registered.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's identity contract\r\n     *  @param _country The country of the investor\r\n     *  emits `IdentityRegistered` event\r\n     */\r\n    function registerIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Removes an user from the identity registry.\r\n     *  Requires that the user have an identity contract already deployed that will be deleted.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user to be removed\r\n     *  emits `IdentityRemoved` event\r\n     */\r\n    function deleteIdentity(address _userAddress) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual identityRegistryStorage contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _identityRegistryStorage The address of the new Identity Registry Storage\r\n     *  emits `IdentityStorageSet` event\r\n     */\r\n    function setIdentityRegistryStorage(\r\n        IIdentityRegistryStorage _identityRegistryStorage\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual claimTopicsRegistry contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _claimTopicsRegistry The address of the new claim Topics Registry\r\n     *  emits `ClaimTopicsRegistrySet` event\r\n     */\r\n    function setClaimTopicsRegistry(\r\n        IClaimTopicsRegistry _claimTopicsRegistry\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual claimIssuersRegistry contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _claimIssuersRegistry The address of the new Claim Issuers Registry\r\n     *  emits `ClaimIssuersRegistrySet` event\r\n     */\r\n    function setClaimIssuersRegistry(\r\n        IClaimIssuersRegistry _claimIssuersRegistry\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Updates the country corresponding to a user address.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _country The new country of the user\r\n     *  emits `CountryUpdated` event\r\n     */\r\n    function updateCountry(address _userAddress, uint16 _country) external;\r\n\r\n    /**\r\n     *  @dev Updates an identity contract corresponding to a user address.\r\n     *  Requires that the user address should be the owner of the identity contract.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's new identity contract\r\n     *  emits `IdentityUpdated` event\r\n     */\r\n    function updateIdentity(address _userAddress, IIdentity _identity) external;\r\n\r\n    /**\r\n     *  @dev function allowing to register identities in batch\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  Requires that none of the users has an identity contract already registered.\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses of the users\r\n     *  @param _identities The addresses of the corresponding identity contracts\r\n     *  @param _countries The countries of the corresponding investors\r\n     *  emits _userAddresses.length `IdentityRegistered` events\r\n     */\r\n    function batchRegisterIdentity(\r\n        address[] calldata _userAddresses,\r\n        IIdentity[] calldata _identities,\r\n        uint16[] calldata _countries\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev This functions checks whether a wallet has its Identity registered or not\r\n     *  in the Identity Registry.\r\n     *  @param _userAddress The address of the user to be checked.\r\n     *  @return 'True' if the address is contained in the Identity Registry, 'false' if not.\r\n     */\r\n    function contains(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev This functions checks whether an identity contract\r\n     *  corresponding to the provided user address has the required claims or not based\r\n     *  on the data fetched from claim issuers registry and from the claim topics registry\r\n     *  @param _userAddress The address of the user to be verified.\r\n     *  @return 'True' if the address is verified, 'false' if not.\r\n     */\r\n    function isVerified(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns the onchainID of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function identity(address _userAddress) external view returns (IIdentity);\r\n\r\n    /**\r\n     *  @dev Returns the country code of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function investorCountry(\r\n        address _userAddress\r\n    ) external view returns (uint16);\r\n\r\n    /**\r\n     *  @dev Returns the IdentityRegistryStorage linked to the current IdentityRegistry.\r\n     */\r\n    function identityStorage() external view returns (IIdentityRegistryStorage);\r\n\r\n    /**\r\n     *  @dev Returns the ClaimIssuersRegistry linked to the current IdentityRegistry.\r\n     */\r\n    function issuersRegistry() external view returns (IClaimIssuersRegistry);\r\n\r\n    /**\r\n     *  @dev Returns the ClaimTopicsRegistry linked to the current IdentityRegistry.\r\n     */\r\n    function topicsRegistry() external view returns (IClaimTopicsRegistry);\r\n}\r\n"
    },
    "contracts/registry/interface/IIdentityRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"@onchain-id/solidity/contracts/interface/IIdentity.sol\";\r\n\r\ninterface IIdentityRegistryStorage {\r\n    /// events\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is registered into the storage contract.\r\n     *  the event is emitted by the 'registerIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityStored(\r\n        address indexed investorAddress,\r\n        IIdentity indexed identity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is removed from the storage contract.\r\n     *  the event is emitted by the 'deleteIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityUnstored(\r\n        address indexed investorAddress,\r\n        IIdentity indexed identity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity has been updated\r\n     *  the event is emitted by the 'updateIdentity' function\r\n     *  `oldIdentity` is the old Identity contract's address to update\r\n     *  `newIdentity` is the new Identity contract's\r\n     */\r\n    event IdentityModified(\r\n        IIdentity indexed oldIdentity,\r\n        IIdentity indexed newIdentity\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity's country has been updated\r\n     *  the event is emitted by the 'updateCountry' function\r\n     *  `investorAddress` is the address on which the country has been updated\r\n     *  `country` is the numeric code (ISO 3166-1) of the new country\r\n     */\r\n    event CountryModified(\r\n        address indexed investorAddress,\r\n        uint16 indexed country\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when an Identity Registry is bound to the storage contract\r\n     *  the event is emitted by the 'addIdentityRegistry' function\r\n     *  `identityRegistry` is the address of the identity registry added\r\n     */\r\n    event IdentityRegistryBound(address indexed identityRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity Registry is unbound from the storage contract\r\n     *  the event is emitted by the 'removeIdentityRegistry' function\r\n     *  `identityRegistry` is the address of the identity registry removed\r\n     */\r\n    event IdentityRegistryUnbound(address indexed identityRegistry);\r\n\r\n    /// functions\r\n\r\n    /**\r\n     *  @dev adds an identity contract corresponding to a user address in the storage.\r\n     *  Requires that the user doesn't have an identity contract already registered.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's identity contract\r\n     *  @param _country The country of the investor\r\n     *  emits `IdentityStored` event\r\n     */\r\n    function addIdentityToStorage(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Removes an user from the storage.\r\n     *  Requires that the user have an identity contract already deployed that will be deleted.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user to be removed\r\n     *  emits `IdentityUnstored` event\r\n     */\r\n    function removeIdentityFromStorage(address _userAddress) external;\r\n\r\n    /**\r\n     *  @dev Updates the country corresponding to a user address.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _country The new country of the user\r\n     *  emits `CountryModified` event\r\n     */\r\n    function modifyStoredInvestorCountry(\r\n        address _userAddress,\r\n        uint16 _country\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Updates an identity contract corresponding to a user address.\r\n     *  Requires that the user address should be the owner of the identity contract.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's new identity contract\r\n     *  emits `IdentityModified` event\r\n     */\r\n    function modifyStoredIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity\r\n    ) external;\r\n\r\n    /**\r\n     *  @notice Adds an identity registry as agent of the Identity Registry Storage Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  This function adds the identity registry to the list of identityRegistries linked to the storage contract\r\n     *  cannot bind more than 300 IR to 1 IRS\r\n     *  @param _identityRegistry The identity registry address to add.\r\n     */\r\n    function bindIdentityRegistry(address _identityRegistry) external;\r\n\r\n    /**\r\n     *  @notice Removes an identity registry from being agent of the Identity Registry Storage Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  This function removes the identity registry from the list of identityRegistries linked to the storage contract\r\n     *  @param _identityRegistry The identity registry address to remove.\r\n     */\r\n    function unbindIdentityRegistry(address _identityRegistry) external;\r\n\r\n    /**\r\n     *  @dev Returns the identity registries linked to the storage contract\r\n     */\r\n    function linkedIdentityRegistries()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /**\r\n     *  @dev Returns the onchainID of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function storedIdentity(\r\n        address _userAddress\r\n    ) external view returns (IIdentity);\r\n\r\n    /**\r\n     *  @dev Returns the country code of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function storedInvestorCountry(\r\n        address _userAddress\r\n    ) external view returns (uint16);\r\n}\r\n"
    },
    "contracts/token/IToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"../registry/interface/IIdentityRegistry.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/// @dev interface\r\ninterface IToken is IERC20 {\r\n    /// events\r\n\r\n    /**\r\n     *  this event is emitted when the onchainID  is updated.\r\n     *  the event is emitted by the token init function and by the setOnchainID function\r\n     *  `_newOnchainID` is the address of the onchainID of the token\r\n     */\r\n    event UpdatedOnchainID(address indexed _newOnchainID);\r\n\r\n    /**\r\n     *  this event is emitted when the IdentityRegistry has been set for the token\r\n     *  the event is emitted by the token constructor and by the setIdentityRegistry function\r\n     *  `_identityRegistry` is the address of the Identity Registry of the token\r\n     */\r\n    event IdentityRegistryAdded(address indexed _identityRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when the Compliance has been set for the token\r\n     *  the event is emitted by the token constructor and by the setCompliance function\r\n     *  `_compliance` is the address of the Compliance contract of the token\r\n     */\r\n    event ComplianceAdded(address indexed _compliance);\r\n\r\n    /**\r\n     *  this event is emitted when an investor successfully recovers his tokens\r\n     *  the event is emitted by the recoveryAddress function\r\n     *  `_lostWallet` is the address of the wallet that the investor lost access to\r\n     *  `_newWallet` is the address of the wallet that the investor provided for the recovery\r\n     *  `_investorOnchainID` is the address of the onchainID of the investor who asked for a recovery\r\n     */\r\n    event RecoverySuccess(\r\n        address indexed _lostWallet,\r\n        address indexed _newWallet,\r\n        address indexed _investorOnchainID\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when the wallet of an investor is frozen or unfrozen\r\n     *  the event is emitted by setAddressFrozen and batchSetAddressFrozen functions\r\n     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status\r\n     *  `_isFrozen` is the freezing status of the wallet\r\n     *  if `_isFrozen` equals `true` the wallet is frozen after emission of the event\r\n     *  if `_isFrozen` equals `false` the wallet is unfrozen after emission of the event\r\n     *  `_owner` is the address of the agent who called the function to freeze the wallet\r\n     */\r\n    event AddressFrozen(\r\n        address indexed _userAddress,\r\n        bool indexed _isFrozen,\r\n        address indexed _owner\r\n    );\r\n\r\n    /**\r\n     *  this event is emitted when a certain amount of tokens is frozen on a wallet\r\n     *  the event is emitted by freezePartialTokens and batchFreezePartialTokens functions\r\n     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status\r\n     *  `_amount` is the amount of tokens that are frozen\r\n     */\r\n    event TokensFrozen(address indexed _userAddress, uint256 _amount);\r\n\r\n    /**\r\n     *  this event is emitted when a certain amount of tokens is unfrozen on a wallet\r\n     *  the event is emitted by unfreezePartialTokens and batchUnfreezePartialTokens functions\r\n     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status\r\n     *  `_amount` is the amount of tokens that are unfrozen\r\n     */\r\n    event TokensUnfrozen(address indexed _userAddress, uint256 _amount);\r\n\r\n    /**\r\n     *  @dev sets the onchain ID of the token\r\n     *  @param _onchainID the address of the onchain ID to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits a `UpdatedTokenInformation` event\r\n     */\r\n    function setOnchainID(address _onchainID) external;\r\n\r\n    /**\r\n     *  @dev pauses the token contract, when contract is paused investors cannot transfer tokens anymore\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `Paused` event\r\n     */\r\n    function pause() external;\r\n\r\n    /**\r\n     *  @dev unpauses the token contract, when contract is unpaused investors can transfer tokens\r\n     *  if their wallet is not blocked & if the amount to transfer is <= to the amount of free tokens\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits an `Unpaused` event\r\n     */\r\n    function unpause() external;\r\n\r\n    /**\r\n     *  @dev sets an address frozen status for this token.\r\n     *  @param _userAddress The address for which to update frozen status\r\n     *  @param _freeze Frozen status of the address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits an `AddressFrozen` event\r\n     */\r\n    function setAddressFrozen(address _userAddress, bool _freeze) external;\r\n\r\n    /**\r\n     *  @dev freezes token amount specified for given address.\r\n     *  @param _userAddress The address for which to update frozen tokens\r\n     *  @param _amount Amount of Tokens to be frozen\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensFrozen` event\r\n     */\r\n    function freezePartialTokens(\r\n        address _userAddress,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev unfreezes token amount specified for given address\r\n     *  @param _userAddress The address for which to update frozen tokens\r\n     *  @param _amount Amount of Tokens to be unfrozen\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event\r\n     */\r\n    function unfreezePartialTokens(\r\n        address _userAddress,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev sets the Identity Registry for the token\r\n     *  @param _identityRegistry the address of the Identity Registry to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits an `IdentityRegistryAdded` event\r\n     */\r\n    function setIdentityRegistry(address _identityRegistry) external;\r\n\r\n    /**\r\n     *  @dev sets the compliance contract of the token\r\n     *  @param _compliance the address of the compliance contract to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  calls bindToken on the compliance contract\r\n     *  emits a `ComplianceAdded` event\r\n     */\r\n    function setCompliance(address _compliance) external;\r\n\r\n    /**\r\n     *  @dev force a transfer of tokens between 2 whitelisted wallets\r\n     *  In case the `from` address has not enough free tokens (unfrozen tokens)\r\n     *  but has a total balance higher or equal to the `amount`\r\n     *  the amount of frozen tokens is reduced in order to have enough free tokens\r\n     *  to proceed the transfer, in such a case, the remaining balance on the `from`\r\n     *  account is 100% composed of frozen tokens post-transfer.\r\n     *  Require that the `to` address is a verified address,\r\n     *  @param _from The address of the sender\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The number of tokens to transfer\r\n     *  @return `true` if successful and revert if unsuccessful\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_from`\r\n     *  emits a `Transfer` event\r\n     */\r\n    function forcedTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     *  @dev mint tokens on a wallet\r\n     *  Improved version of default mint method. Tokens can be minted\r\n     *  to an address if only it is a verified address as per the security token.\r\n     *  @param _to Address to mint the tokens to.\r\n     *  @param _amount Amount of tokens to mint.\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `Transfer` event\r\n     */\r\n    function mint(address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev burn tokens on a wallet\r\n     *  In case the `account` address has not enough free tokens (unfrozen tokens)\r\n     *  but has a total balance higher or equal to the `value` amount\r\n     *  the amount of frozen tokens is reduced in order to have enough free tokens\r\n     *  to proceed the burn, in such a case, the remaining balance on the `account`\r\n     *  is 100% composed of frozen tokens post-transaction.\r\n     *  @param _userAddress Address to burn the tokens from.\r\n     *  @param _amount Amount of tokens to burn.\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_userAddress`\r\n     *  emits a `Transfer` event\r\n     */\r\n    function burn(address _userAddress, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev recovery function used to force transfer tokens from a\r\n     *  lost wallet to a new wallet for an investor.\r\n     *  @param _lostWallet the wallet that the investor lost\r\n     *  @param _newWallet the newly provided wallet on which tokens have to be transferred\r\n     *  @param _investorOnchainID the onchainID of the investor asking for a recovery\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event if there is some frozen tokens on the lost wallet if the recovery process is successful\r\n     *  emits a `Transfer` event if the recovery process is successful\r\n     *  emits a `RecoverySuccess` event if the recovery process is successful\r\n     *  emits a `RecoveryFails` event if the recovery process fails\r\n     */\r\n    function recoveryAddress(\r\n        address _lostWallet,\r\n        address _newWallet,\r\n        address _investorOnchainID\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     *  @dev function allowing to issue transfers in batch\r\n     *  Require that the msg.sender and `to` addresses are not frozen.\r\n     *  Require that the total value should not exceed available balance.\r\n     *  Require that the `to` addresses are all verified addresses,\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _toList The addresses of the receivers\r\n     *  @param _amounts The number of tokens to transfer to the corresponding receiver\r\n     *  emits _toList.length `Transfer` events\r\n     */\r\n    function batchTransfer(\r\n        address[] calldata _toList,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to issue forced transfers in batch\r\n     *  Require that `_amounts[i]` should not exceed available balance of `_fromList[i]`.\r\n     *  Require that the `_toList` addresses are all verified addresses\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_fromList.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _fromList The addresses of the senders\r\n     *  @param _toList The addresses of the receivers\r\n     *  @param _amounts The number of tokens to transfer to the corresponding receiver\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits `TokensUnfrozen` events if `_amounts[i]` is higher than the free balance of `_fromList[i]`\r\n     *  emits _fromList.length `Transfer` events\r\n     */\r\n    function batchForcedTransfer(\r\n        address[] calldata _fromList,\r\n        address[] calldata _toList,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to mint tokens in batch\r\n     *  Require that the `_toList` addresses are all verified addresses\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _toList The addresses of the receivers\r\n     *  @param _amounts The number of tokens to mint to the corresponding receiver\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _toList.length `Transfer` events\r\n     */\r\n    function batchMint(\r\n        address[] calldata _toList,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to burn tokens in batch\r\n     *  Require that the `_userAddresses` addresses are all verified addresses\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses of the wallets concerned by the burn\r\n     *  @param _amounts The number of tokens to burn from the corresponding wallets\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `Transfer` events\r\n     */\r\n    function batchBurn(\r\n        address[] calldata _userAddresses,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to set frozen addresses in batch\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses for which to update frozen status\r\n     *  @param _freeze Frozen status of the corresponding address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `AddressFrozen` events\r\n     */\r\n    function batchSetAddressFrozen(\r\n        address[] calldata _userAddresses,\r\n        bool[] calldata _freeze\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to freeze tokens partially in batch\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses on which tokens need to be frozen\r\n     *  @param _amounts the amount of tokens to freeze on the corresponding address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `TokensFrozen` events\r\n     */\r\n    function batchFreezePartialTokens(\r\n        address[] calldata _userAddresses,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to unfreeze tokens partially in batch\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses on which tokens need to be unfrozen\r\n     *  @param _amounts the amount of tokens to unfreeze on the corresponding address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `TokensUnfrozen` events\r\n     */\r\n    function batchUnfreezePartialTokens(\r\n        address[] calldata _userAddresses,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 1 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * balanceOf() and transfer().\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the address of the onchainID of the token.\r\n     * the onchainID of the token gives all the information available\r\n     * about the token and is managed by the token issuer or his agent.\r\n     */\r\n    function onchainID() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the TREX version of the token.\r\n     * current version is 3.0.0\r\n     */\r\n    function version() external view returns (string memory);\r\n\r\n    /**\r\n     *  @dev Returns the Identity Registry linked to the token\r\n     */\r\n    function identityRegistry() external view returns (IIdentityRegistry);\r\n\r\n    /**\r\n     *  @dev Returns the Compliance contract linked to the token\r\n     */\r\n    function compliance() external view returns (address);\r\n\r\n    /**\r\n     *  @dev Returns the freezing status of a wallet\r\n     *  if isFrozen returns `true` the wallet is frozen\r\n     *  if isFrozen returns `false` the wallet is not frozen\r\n     *  isFrozen returning `true` doesn't mean that the balance is free, tokens could be blocked by\r\n     *  a partial freeze or the whole token could be blocked by pause\r\n     *  @param _userAddress the address of the wallet on which isFrozen is called\r\n     */\r\n    function isFrozen(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns the amount of tokens that are partially frozen on a wallet\r\n     *  the amount of frozen tokens is always <= to the total balance of the wallet\r\n     *  @param _userAddress the address of the wallet on which getFrozenTokens is called\r\n     */\r\n    function getFrozenTokens(\r\n        address _userAddress\r\n    ) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/token/Token.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.17;\r\n\r\nimport \"./IToken.sol\";\r\nimport \"@onchain-id/solidity/contracts/interface/IIdentity.sol\";\r\n\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\n\r\nimport \"../compliance/interface/ICompliance.sol\";\r\n\r\n/// @title ERC-3643 - T-Rex Token (Version RAPTOR-5.0.0)\r\n/// @notice An ERC-3643 compliant token with onchain validators and compliance checks.\r\ncontract Token is IToken, AccessControl, Pausable {\r\n    /// @dev ERC20 basic variables\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    /// @dev Variables of freeze and pause functions\r\n    mapping(address => bool) private _frozen;\r\n    mapping(address => uint256) private _frozenAmounts;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /// @dev Token information\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private immutable _decimals;\r\n    address private _onchainID;\r\n    string private constant _TOKEN_VERSION = \"RAPTOR-5.0.0\";\r\n\r\n    // keccak256(AGENT_ROLE)\r\n    bytes32 public constant AGENT_ROLE =\r\n        0xcab5a0bfe0b79d2c4b1c2e02599fa044d115b7511f9659307cb4276950967709;\r\n\r\n    // keccak256(OWNER_ROLE)\r\n    bytes32 public constant OWNER_ROLE =\r\n        0xb19546dff01e856fb3f010c267a7b1c60363cf8a4664e21cc89c26224620214e;\r\n\r\n    /// @dev Identity Registry contract used by the onchain validator system\r\n    IIdentityRegistry private _identityRegistry;\r\n\r\n    /// @dev Compliance contract linked to the onchain validator system\r\n    ICompliance private _compliance;\r\n\r\n    /// @dev the constructor initiates the token contract\r\n    /// _msgSender() is set automatically as the owner of the smart contract\r\n    /// @param identityRegistry_ the address of the Identity registry linked to the token\r\n    /// @param compliance_ the address of the compliance contract linked to the token\r\n    /// @param name_ the name of the token\r\n    /// @param symbol_ the symbol of the token\r\n    /// @param decimals_ the decimals of the token\r\n    /// @param onchainID_ the address of the onchainID of the token\r\n    /// emits an `UpdatedTokenInformation` event\r\n    /// emits an `IdentityRegistryAdded` event\r\n    /// emits a `ComplianceAdded` event\r\n    constructor(\r\n        address identityRegistry_,\r\n        address compliance_,\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_,\r\n        address onchainID_\r\n    ) {\r\n        require(\r\n            identityRegistry_ != address(0) && compliance_ != address(0),\r\n            \"ERC-3643: Invalid zero address\"\r\n        );\r\n\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n        _onchainID = onchainID_;\r\n\r\n        _grantRole(bytes32(0), _msgSender());\r\n        _grantRole(OWNER_ROLE, _msgSender());\r\n        _grantRole(AGENT_ROLE, _msgSender());\r\n\r\n        _identityRegistry = IIdentityRegistry(identityRegistry_);\r\n        _compliance = ICompliance(compliance_);\r\n        _compliance.bindToken(address(this));\r\n\r\n        emit IdentityRegistryAdded(identityRegistry_);\r\n        emit ComplianceAdded(compliance_);\r\n        emit UpdatedOnchainID(_onchainID);\r\n    }\r\n\r\n    /// @notice Approve `amount` tokens to be spent by `spender`\r\n    /// @param spender The address of the account allowed to spend the tokens\r\n    /// @param amount The number of tokens to be spent\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice ERC-20 overridden function that include logic to check for trade validity.\r\n    /// @dev Transfer tokens to another address. Requires that the _msgSender()\r\n    /// and to addresses are not frozen and that the value should not exceed available balance.\r\n    /// @param to The address of the receiver.\r\n    /// @param amount The number of tokens to transfer.\r\n    /// @return true if the transfer is successful.\r\n    function transfer(\r\n        address to,\r\n        uint256 amount\r\n    ) external whenNotPaused returns (bool) {\r\n        _transfer(_msgSender(), to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev ERC-20 overridden function that include logic to check for trade validity\r\n    /// @dev Transfer tokens from one address to another. Requires that the `from` and `to` addresses are not frozen\r\n    /// and that the value should not exceed available balance.\r\n    /// @param from The address of the sender.\r\n    /// @param to The address of the receiver.\r\n    /// @param amount The number of tokens to transfer.\r\n    /// @return true if the transfer is successful.\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external whenNotPaused returns (bool) {\r\n        _spendAllowance(from, _msgSender(), amount);\r\n        _transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Increase the allowance provided to `spender` by the caller\r\n    /// @param spender The address of the account allowed to spend the tokens\r\n    /// @param _addedValue The increase in allowance\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 _addedValue\r\n    ) external returns (bool) {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender] + (_addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /// @notice Decrease the allowance provided to `spender` by the caller\r\n    /// @param spender The address of the account allowed to spend the tokens\r\n    /// @param _subtractedValue The decrease in allowance\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 _subtractedValue\r\n    ) external returns (bool) {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender] - _subtractedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /// @dev Set the onchainID of a token. Can only be called by an owner of the contract.\r\n    /// @param onchainID_ The address of the onchainID.\r\n    /// @notice Emits an UpdatedOnchainID event.\r\n    function setOnchainID(address onchainID_) external onlyRole(OWNER_ROLE) {\r\n        _onchainID = onchainID_;\r\n        emit UpdatedOnchainID(onchainID_);\r\n    }\r\n\r\n    /// @notice Pause all token operations\r\n    /// @dev Can only be called by an agent of the contract\r\n    function pause() external onlyRole(AGENT_ROLE) {\r\n        _pause();\r\n    }\r\n\r\n    /// @notice Unpause all token operations\r\n    /// @dev Can only be called by an agent of the contract\r\n    function unpause() external onlyRole(AGENT_ROLE) {\r\n        _unpause();\r\n    }\r\n\r\n    // @dev Perform a batch transfer of tokens.\r\n    /// @param toList An array of receiver addresses.\r\n    /// @param amounts An array of amounts to transfer.\r\n    function batchTransfer(\r\n        address[] calldata toList,\r\n        uint256[] calldata amounts\r\n    ) external whenNotPaused {\r\n        uint length = toList.length;\r\n        require(length == amounts.length, \"ERC-3643: Array size mismatch\");\r\n\r\n        for (uint256 i = 0; i < length; ) {\r\n            _transfer(_msgSender(), toList[i], amounts[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a batch forced transfer of tokens.\r\n    /// @param fromList An array of sender addresses.\r\n    /// @param toList An array of receiver addresses.\r\n    /// @param amounts An array of amounts to transfer.\r\n    function batchTransferFrom(\r\n        address[] calldata fromList,\r\n        address[] calldata toList,\r\n        uint256[] calldata amounts\r\n    ) external whenNotPaused {\r\n        uint length = fromList.length;\r\n        require(length == toList.length, \"ERC-3643: Array size mismatch\");\r\n        require(length == amounts.length, \"ERC-3643: Array size mismatch\");\r\n\r\n        for (uint256 i = 0; i < length; ) {\r\n            _spendAllowance(fromList[i], _msgSender(), amounts[i]);\r\n            _transfer(fromList[i], toList[i], amounts[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a batch forced transfer of tokens.\r\n    /// @param fromList An array of sender addresses.\r\n    /// @param toList An array of receiver addresses.\r\n    /// @param amounts An array of amounts to transfer.\r\n    function batchForcedTransfer(\r\n        address[] calldata fromList,\r\n        address[] calldata toList,\r\n        uint256[] calldata amounts\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        uint length = fromList.length;\r\n        require(length == toList.length, \"ERC-3643: Array size mismatch\");\r\n        require(length == amounts.length, \"ERC-3643: Array size mismatch\");\r\n\r\n        for (uint256 i = 0; i < length; ) {\r\n            _forcedTransfer(fromList[i], toList[i], amounts[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a batch minting of tokens.\r\n    /// @param toList An array of receiver addresses.\r\n    /// @param amounts An array of amounts to mint.\r\n    function batchMint(\r\n        address[] calldata toList,\r\n        uint256[] calldata amounts\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        uint length = toList.length;\r\n        require(length == amounts.length, \"ERC-3643: Array size mismatch\");\r\n\r\n        for (uint256 i = 0; i < length; ) {\r\n            _mint(toList[i], amounts[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a batch burn of tokens.\r\n    /// @param accounts An array of addresses from which to burn tokens.\r\n    /// @param amounts An array of amounts to burn.\r\n    function batchBurn(\r\n        address[] calldata accounts,\r\n        uint256[] calldata amounts\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        uint length = accounts.length;\r\n        require(length == amounts.length, \"ERC-3643: Array size mismatch\");\r\n\r\n        for (uint256 i = 0; i < length; ) {\r\n            _burn(accounts[i], amounts[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a batch freezing / unfreezing of addresses.\r\n    /// @param accounts An array of addresses to freeze.\r\n    /// @param freeze An array of boolean values indicating whether to freeze the corresponding address.\r\n    function batchSetAddressFrozen(\r\n        address[] calldata accounts,\r\n        bool[] calldata freeze\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        uint length = accounts.length;\r\n        require(length == freeze.length, \"ERC-3643: Array size mismatch\");\r\n\r\n        for (uint256 i = 0; i < length; ) {\r\n            _setAddressFrozen(accounts[i], freeze[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a batch freezing of partial tokens from multiple addresses.\r\n    /// @param accounts An array of addresses from which to freeze tokens.\r\n    /// @param amounts An array of amounts to freeze.\r\n    function batchFreezePartialTokens(\r\n        address[] calldata accounts,\r\n        uint256[] calldata amounts\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        uint length = accounts.length;\r\n        require(length == amounts.length, \"ERC-3643: Array size mismatch\");\r\n\r\n        for (uint256 i = 0; i < length; ) {\r\n            _freezePartialTokens(accounts[i], amounts[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a batch unfreezing of partial tokens from multiple addresses.\r\n    /// @param accounts An array of addresses from which to unfreeze tokens.\r\n    /// @param amounts An array of amounts to unfreeze.\r\n    function batchUnfreezePartialTokens(\r\n        address[] calldata accounts,\r\n        uint256[] calldata amounts\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        uint length = accounts.length;\r\n        require(length == amounts.length, \"ERC-3643: Array size mismatch\");\r\n\r\n        for (uint256 i = 0; i < length; ) {\r\n            _unfreezePartialTokens(accounts[i], amounts[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Recover tokens from a lost wallet and transfer them to a new wallet. Can only be called by an agent of the contract.\r\n    /// @param lostWallet The address of the lost wallet.\r\n    /// @param newWallet The address of the new wallet.\r\n    /// @param investorOnchainID The onchainID of the investor.\r\n    /// @return true if the recovery is successful.\r\n    function recoveryAddress(\r\n        address lostWallet,\r\n        address newWallet,\r\n        address investorOnchainID\r\n    ) external onlyRole(AGENT_ROLE) returns (bool) {\r\n        uint256 investorBalance = _balances[lostWallet];\r\n        require(investorBalance != 0, \"ERC-3643: No tokens to recover\");\r\n\r\n        IIdentity identity = IIdentity(investorOnchainID);\r\n\r\n        bool isLostWalletFrozen = _frozen[lostWallet];\r\n        bytes32 _key = keccak256(abi.encode(newWallet));\r\n        require(\r\n            identity.keyHasPurpose(_key, 1),\r\n            \"ERC-3643: Recovery not possible\"\r\n        );\r\n        uint256 frozenTokens = _frozenAmounts[lostWallet];\r\n\r\n        _identityRegistry.registerIdentity(\r\n            newWallet,\r\n            identity,\r\n            _identityRegistry.investorCountry(lostWallet)\r\n        );\r\n\r\n        if (isLostWalletFrozen) _frozen[lostWallet] = false;\r\n\r\n        _forcedTransfer(lostWallet, newWallet, investorBalance);\r\n\r\n        if (frozenTokens != 0) {\r\n            _freezePartialTokens(newWallet, frozenTokens);\r\n        }\r\n        if (isLostWalletFrozen == true) {\r\n            _setAddressFrozen(newWallet, true);\r\n        }\r\n        _identityRegistry.deleteIdentity(lostWallet);\r\n\r\n        emit RecoverySuccess(lostWallet, newWallet, investorOnchainID);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Executes a forced transfer of tokens from one address to another\r\n    /// @param from The address from which the tokens will be transferred\r\n    /// @param to The address to which the tokens will be transferred\r\n    /// @param amount The number of tokens to be transferred\r\n    /// @return Returns true if the transfer was successful, otherwise false\r\n    function forcedTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external onlyRole(AGENT_ROLE) returns (bool) {\r\n        return _forcedTransfer(from, to, amount);\r\n    }\r\n\r\n    /// @notice Mints new tokens and assigns them to a specified address\r\n    /// @param _to The address that will receive the minted tokens\r\n    /// @param amount The number of tokens to be minted\r\n    function mint(address _to, uint256 amount) external onlyRole(AGENT_ROLE) {\r\n        _mint(_to, amount);\r\n    }\r\n\r\n    /// @notice Burns tokens from a specified address\r\n    /// @param account The address from which the tokens will be burned\r\n    /// @param amount The number of tokens to be burned\r\n    function burn(\r\n        address account,\r\n        uint256 amount\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        _burn(account, amount);\r\n    }\r\n\r\n    /// @notice Freezes or unfreezes a specified address\r\n    /// @param account The address to be frozen or unfrozen\r\n    /// @param freeze The boolean value indicating whether to freeze (true) or unfreeze (false) the account\r\n    function setAddressFrozen(\r\n        address account,\r\n        bool freeze\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        _frozen[account] = freeze;\r\n\r\n        emit AddressFrozen(account, freeze, _msgSender());\r\n    }\r\n\r\n    /// @notice Freezes a specified amount of tokens in a specified account\r\n    /// @param account The account in which the tokens will be frozen\r\n    /// @param amount The amount of tokens to be frozen\r\n    function freezePartialTokens(\r\n        address account,\r\n        uint256 amount\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        _freezePartialTokens(account, amount);\r\n    }\r\n\r\n    /// @notice Unfreezes a specified amount of tokens in a specified account\r\n    /// @param account The account from which the tokens will be unfrozen\r\n    /// @param amount The amount of tokens to be unfrozen\r\n    function unfreezePartialTokens(\r\n        address account,\r\n        uint256 amount\r\n    ) external onlyRole(AGENT_ROLE) {\r\n        _unfreezePartialTokens(account, amount);\r\n    }\r\n\r\n    /// @notice Sets the Identity Registry contract address\r\n    /// @param newIdentityRegistry The address of the new Identity Registry contract\r\n    function setIdentityRegistry(\r\n        address newIdentityRegistry\r\n    ) external onlyRole(OWNER_ROLE) {\r\n        _identityRegistry = IIdentityRegistry(newIdentityRegistry);\r\n        emit IdentityRegistryAdded(newIdentityRegistry);\r\n    }\r\n\r\n    /// @notice Sets the Compliance contract address\r\n    /// @param newCompliance The address of the new Compliance contract\r\n    function setCompliance(\r\n        address newCompliance\r\n    ) external onlyRole(OWNER_ROLE) {\r\n        require(newCompliance != address(0), \"ERC-3643: Invalid zero address\");\r\n\r\n        _compliance.unbindToken(address(this));\r\n        _compliance = ICompliance(newCompliance);\r\n        _compliance.bindToken(address(this));\r\n        emit ComplianceAdded(newCompliance);\r\n    }\r\n\r\n    /// @dev Returns the name of the token.\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /// @dev Returns the symbol of the token.\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /// @dev Returns the number of decimals the token uses.\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /// @dev Returns the onchainID of the token.\r\n    function onchainID() external view returns (address) {\r\n        return _onchainID;\r\n    }\r\n\r\n    /// @notice Get the balance of a specified account.\r\n    /// @param account The address of the account.\r\n    /// @return uint256 The balance of the specified account.\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /// @dev Returns the total supply of the token.\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /// @dev Returns the allowance of tokens that an owner has allowed a spender to spend.\r\n    /// @param owner The address of the owner.\r\n    /// @param spender The address of the spender.\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /// @dev Returns whether an address is frozen.\r\n    /// @param account The address to check.\r\n    function isFrozen(address account) external view returns (bool) {\r\n        return _frozen[account];\r\n    }\r\n\r\n    /// @dev Returns the number of frozen tokens of an address.\r\n    /// @param account The address to check.\r\n    function getFrozenTokens(address account) external view returns (uint256) {\r\n        return _frozenAmounts[account];\r\n    }\r\n\r\n    /// @dev Returns the current Compliance contract linked to the token.\r\n    function compliance() external view returns (address) {\r\n        return address(_compliance);\r\n    }\r\n\r\n    /// @dev Returns the current Identity Registry contract linked to the token.\r\n    function identityRegistry() external view returns (IIdentityRegistry) {\r\n        return _identityRegistry;\r\n    }\r\n\r\n    /// @dev Returns the version of the token.\r\n    function version() external pure returns (string memory) {\r\n        return _TOKEN_VERSION;\r\n    }\r\n\r\n    /// @notice ERC-20 overridden function that include logic to check for trade validity.\r\n    /// Require that the `from` and `to` addresses are not frozen.\r\n    /// Require that the `amount` should not exceed available balance .\r\n    /// Require that the `to` address is a verified address\r\n    /// @param from The address of the sender\r\n    /// @param to The address of the receiver\r\n    /// @param amount The number of tokens to transfer\r\n    function _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \"ERC-3643: transfer from zero address\");\r\n        require(to != address(0), \"ERC-3643: transfer to zero address\");\r\n\r\n        require(!_frozen[to] && !_frozen[from], \"ERC-3643: Wallet frozen\");\r\n        uint256 fromBalance = _balances[from];\r\n\r\n        require(fromBalance >= amount, \"ERC-3643: amount exceeds balance\");\r\n        require(\r\n            amount <= fromBalance - (_frozenAmounts[from]),\r\n            \"ERC-3643: Freezed balance\"\r\n        );\r\n\r\n        require(\r\n            _identityRegistry.isVerified(to),\r\n            \"ERC-3643: Unverified identity\"\r\n        );\r\n        require(\r\n            _compliance.canTransfer(from, to, amount),\r\n            \"ERC-3643: Compliance failure\"\r\n        );\r\n\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n        _compliance.transferred(_msgSender(), to, amount);\r\n    }\r\n\r\n    /// @dev Mints the amount of tokens to the `account`\r\n    /// @param account The address of the receiver\r\n    /// @param amount The number of tokens to mint\r\n    function _mint(address account, uint256 amount) private {\r\n        require(account != address(0), \"ERC-3643: mint to zero address\");\r\n        require(\r\n            _identityRegistry.isVerified(account),\r\n            \"ERC-3643: Unverified identity\"\r\n        );\r\n        require(\r\n            _compliance.canTransfer(address(0), account, amount),\r\n            \"ERC-3643: Compliance failure\"\r\n        );\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n\r\n        emit Transfer(address(0), account, amount);\r\n        _compliance.created(account, amount);\r\n    }\r\n\r\n    /// @dev Burns the amount of tokens from the sender's account\r\n    /// @param account The address of the sender\r\n    /// @param amount The number of tokens to burn\r\n    function _burn(address account, uint256 amount) private {\r\n        require(account != address(0), \"ERC-3643: burn from the zero address\");\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC-3643: burn exceeds balance\");\r\n\r\n        uint256 freeBalance = accountBalance - _frozenAmounts[account];\r\n        if (amount > freeBalance) {\r\n            uint256 tokensToUnfreeze = amount - (freeBalance);\r\n            _frozenAmounts[account] =\r\n                _frozenAmounts[account] -\r\n                (tokensToUnfreeze);\r\n            emit TokensUnfrozen(account, tokensToUnfreeze);\r\n        }\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n        _compliance.destroyed(account, amount);\r\n    }\r\n\r\n    /// @notice Approve a specified amount for a spender.\r\n    /// @dev private function that approves a specified amount for a spender.\r\n    /// Emits an Approval event.\r\n    /// @param owner The address of the owner.\r\n    /// @param spender The address of the spender.\r\n    /// @param amount The amount to approve.\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC-3643: approve from zero address\");\r\n        require(spender != address(0), \"ERC-3643: approve to zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /// @notice Forced transfer of a specified amount from one address to another.\r\n    /// @dev Private function to transfer tokens from one address to another.\r\n    /// Requires that the `from` address has enough balance. Adjusts frozen tokens if necessary.\r\n    /// @param from The address to transfer from.\r\n    /// @param to The address to transfer to.\r\n    /// @param amount The amount to transfer.\r\n    /// @return true if the forced transfer is successful.\r\n    function _forcedTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private returns (bool) {\r\n        uint fromBalance = _balances[from];\r\n\r\n        require(fromBalance >= amount, \"ERC-3643: Sender low balance\");\r\n        uint256 freeBalance = fromBalance - (_frozenAmounts[from]);\r\n        if (amount > freeBalance) {\r\n            uint256 tokensToUnfreeze = amount - (freeBalance);\r\n            _frozenAmounts[from] = _frozenAmounts[from] - (tokensToUnfreeze);\r\n            emit TokensUnfrozen(from, tokensToUnfreeze);\r\n        }\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Decreases the allowance of the spender for the sender's tokens\r\n    /// @param owner The address of the sender\r\n    /// @param spender The address of the spender\r\n    /// @param amount The number of tokens to decrease the allowance by\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        uint256 currentAllowance = _allowances[owner][spender];\r\n\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"ERC3643: Insufficient allowance\"\r\n            );\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Freezes or unfreezes the account\r\n    /// @param account The address of the account\r\n    /// @param freeze The boolean value of whether to freeze or unfreeze the account\r\n    function _setAddressFrozen(address account, bool freeze) private {\r\n        _frozen[account] = freeze;\r\n\r\n        emit AddressFrozen(account, freeze, _msgSender());\r\n    }\r\n\r\n    /// @dev Freezes the amount of tokens in the account\r\n    /// @param account The address of the account\r\n    /// @param amount The number of tokens to freeze\r\n    function _freezePartialTokens(address account, uint256 amount) private {\r\n        uint256 balance = _balances[account];\r\n        require(\r\n            balance >= _frozenAmounts[account] + amount,\r\n            \"Amount exceeds available balance\"\r\n        );\r\n        _frozenAmounts[account] = _frozenAmounts[account] + (amount);\r\n        emit TokensFrozen(account, amount);\r\n    }\r\n\r\n    /// @dev Unfreezes the amount of tokens in the account\r\n    /// @param account The address of the account\r\n    /// @param amount The number of tokens to unfreeze\r\n    function _unfreezePartialTokens(address account, uint256 amount) private {\r\n        require(\r\n            _frozenAmounts[account] >= amount,\r\n            \"Amount should be less than or equal to frozen tokens\"\r\n        );\r\n        unchecked {\r\n            _frozenAmounts[account] = _frozenAmounts[account] - (amount);\r\n        }\r\n        emit TokensUnfrozen(account, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/YourContract.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// Useful for debugging. Remove when deploying to a live network.\r\nimport \"hardhat/console.sol\";\r\n\r\n// Use openzeppelin to inherit battle-tested implementations (ERC20, ERC721, etc)\r\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * A smart contract that allows changing a state variable of the contract and tracking the changes\r\n * It also allows the owner to withdraw the Ether in the contract\r\n * @author BuidlGuidl\r\n */\r\ncontract YourContract {\r\n\t// State Variables\r\n\taddress public immutable owner;\r\n\tstring public greeting = \"Building Unstoppable Apps!!!\";\r\n\tbool public premium = false;\r\n\tuint256 public totalCounter = 0;\r\n\tmapping(address => uint) public userGreetingCounter;\r\n\r\n\t// Events: a way to emit log statements from smart contract that can be listened to by external parties\r\n\tevent GreetingChange(\r\n\t\taddress indexed greetingSetter,\r\n\t\tstring newGreeting,\r\n\t\tbool premium,\r\n\t\tuint256 value\r\n\t);\r\n\r\n\t// Constructor: Called once on contract deployment\r\n\t// Check packages/hardhat/deploy/00_deploy_your_contract.ts\r\n\tconstructor(address _owner) {\r\n\t\towner = _owner;\r\n\t}\r\n\r\n\t// Modifier: used to define a set of rules that must be met before or after a function is executed\r\n\t// Check the withdraw() function\r\n\tmodifier isOwner() {\r\n\t\t// msg.sender: predefined variable that represents address of the account that called the current function\r\n\t\trequire(msg.sender == owner, \"Not the Owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Function that allows anyone to change the state variable \"greeting\" of the contract and increase the counters\r\n\t *\r\n\t * @param _newGreeting (string memory) - new greeting to save on the contract\r\n\t */\r\n\tfunction setGreeting(string memory _newGreeting) public payable {\r\n\t\t// Print data to the hardhat chain console. Remove when deploying to a live network.\r\n\t\tconsole.log(\r\n\t\t\t\"Setting new greeting '%s' from %s\",\r\n\t\t\t_newGreeting,\r\n\t\t\tmsg.sender\r\n\t\t);\r\n\r\n\t\t// Change state variables\r\n\t\tgreeting = _newGreeting;\r\n\t\ttotalCounter += 1;\r\n\t\tuserGreetingCounter[msg.sender] += 1;\r\n\r\n\t\t// msg.value: built-in global variable that represents the amount of ether sent with the transaction\r\n\t\tif (msg.value > 0) {\r\n\t\t\tpremium = true;\r\n\t\t} else {\r\n\t\t\tpremium = false;\r\n\t\t}\r\n\r\n\t\t// emit: keyword used to trigger an event\r\n\t\temit GreetingChange(msg.sender, _newGreeting, msg.value > 0, msg.value);\r\n\t}\r\n\r\n\t/**\r\n\t * Function that allows the owner to withdraw all the Ether in the contract\r\n\t * The function can only be called by the owner of the contract as defined by the isOwner modifier\r\n\t */\r\n\tfunction withdraw() public isOwner {\r\n\t\t(bool success, ) = owner.call{ value: address(this).balance }(\"\");\r\n\t\trequire(success, \"Failed to send Ether\");\r\n\t}\r\n\r\n\t/**\r\n\t * Function that allows the contract to receive ETH\r\n\t */\r\n\treceive() external payable {}\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}